> **Redux-saga** - это менеджер сайд-эффектов (middlewares).

> **Сайд-эффект** - (middleware) это действие которое выполняется на диспатч экшена.

> **Saga** - паттерн управления процессами, которые выполняются транзакционно, т.е. как одно атомарное действие.

`yarn add redux-saga` - установка

`createSagaMiddleware()` - функция создания мидлвар; с помощью неё создаётся инстанс и передаётся в  
compose -> applyMiddleware -> createStore редакса (или подобную в RTK).

```
const sagaMiddleware = createSagaMiddleware();

const store = createStore(
  ...
  compose(applyMiddleware(sagaMiddleware))
);

sagaMiddleware.run(saga);  // watcher
```

## Sagas

**2 вида:**
- watcher-saga - слушает actions и назначает выполнение worker-saga; в имени обычно используется saga.
- worker-saga - выполняет делегируемое watcher-saga

> Каждая saga это generator.

```
// пример worker-saga; запускает fetchPosts на каждый диспатч экшена POST_REQUESTED
export function* sags() {
  yield takeEvery(POST_REQUESTED, fetchPost);
}
```

___

## Effects

> Это помощники для прослушивания экшенов; импортируются из `redux-saga/effects`.

`TakeEvery` - хелпер который прослушивает action (конкретный или '*') и запускает worker-saga.

`put()` - эффект для диспатча внутри саги.

`call([this, fn], action)` - запускает функцию.
`call({context, fn}, action)` - другой вариант

`apply(context, fn, [args])` - эффект аналогичен apply в js; как и call, является блокирующим.

`takeLatest` - выполняет только одну текущую задачу, игнорируя остальные.

`delay(ms)` - эффект для остановки flow на время.

`throttle(delay, action, handler)` - эффект который делает только одно действие в течении задержки.

`debounce(delay, action, handler)` - выполнит handler когда юзер закончит ввод в input + delay.

**Flow:**
- диспатчим экшен в компоненте
- saga-watcher прослушивает экшен с таким типом и запускает saga-worker
- saga-worker делает запрос на сервер

### Blocking/non-blocking effects

> **Blocking** - когда saga делает yield эффекта, будет ожидать завершения вызова, затем перейдёт к выполнению  
> следующего эффекта.

> Блокирующие: call, take, retry, takeMaybe

> Не блокирующие: put, fork, takeEvery, takeLatest

`all` - блокируется если в массиве есть блокирующий эффект, иначе - не блокирующий.

`fork` - attach effect (ошибки в нём всплывают до родителя); не блокирующий аналог call; возвращает task.

`spawn` - как fork, но detached effect - ошибки не всплывают.

> При использовании spawn, если произойдёт ошибка, то выполнение родительской саги продолжится.  
> Также, если отменить родительскую сагу, то задачи spawn не отменятся, нужно отменять явно каждую.  
> Т.е. fork привязан к родителю, а spawn нет.

`cancel` - эффект отменяет задачу.

`cancelled` - эффект вернёт true если сработал cancel.

### Take effects

`takeEvery` - прослушивает экшены переданного типа и выполняет переданный обработчик;  
принимает первым аргументом action/action[]/channel/'*'; второй аргумент - обработчик (например worker-saga).

`takeLatest` - выполняет задачу, пришедшую позже всех, предыдущие будут отменены; аргументы как в takeLatest.

`takeLeading` - выполняет первую задачу, последующие игнорируются.

`take` - используется в связке с бесконечным циклом (while (true)), т.к. take - блокирующий эффект и цикл  
нужен чтобы прослушивание экшенов не прекращалось (бесконечный цикл в generator* безопасен и не приведёт к  
stack overflow);  
принимает 1 аргумент, но из него можно получить экшен и использовать дальше;  
take позволяет тонко настроить обработку экшена, в отличии от takeEvery.

```
while (true) {
  const action = yield take(ACTION);
  yield call(handler, action);
}
```

___

## Channels

> Позволяют создавать очередь из последовательных запросов;  
> очередь хранится в буфере.

**3 вида каналов:**
- channel - используется для общения саг между собой
- action channel - привязать экшены
- event channel - позволяет привязать внешний источник данных (WebSockets)

> В отличии от `takeEvery + put` (выполняет запросы конкурентно), action channel выполняет запросы последовательно.

`channel` - не привязан к источнику данных, в него можно отправить данные через put();  
сообщения буферизуются по дефолту; используется для общения между сагами.

`channel()` - фабрика создания инстансов каналов.

### Event channel

`eventChannel` - Позволяет получать события из других источников (ws).

`eventChannel(emit => {})` - создать канал; принимает функцию, в которой инициализируется соединение к стороннему  
источнику событий.

### Buffers

> Все виды каналов могут принимать buffets аргументом.

**5 видов:**
- `none()` - все сообщения, которые попадут в буфер, будут игнорироваться
- `fixed(limit)` - задаёт лимит сообщений, если превысить, то выбросит ошибку overflow; 10 по дефолту
- `expanding(initialSize)` - если буфер превысит initialSize, то будет динамически расширяться
- `dropping(limit)` - как fixed, но излишек игнорируется без ошибки
- `sliding(limit)` - при превышении лимита, старые сообщения будут отбрасываться

___

## Context. Внедрение зависимостей

> Зависимости передаются в поле context при создании middleware.

```
const sagaMiddleware = createSagaMiddleware({
  context: {
    someApi
  }
});

// внутри саги
const someApi = yield getContext('someApi');
```

`getContext/setContext` - получение/расширение контекста.

___

## Запуск нескольких саг

(1)
> `all()` - саги выполняются параллельно, all работает пока все саги не выполнятся;  
> при возникновении необработанной ошибки в саге внутри all, ошибка всплывает на самый верх и рутовая сага упадёт.  
> all - блокирующий эффект, работает пока не выполнятся все дочерние саги, только тогда сработает код после all.  
> Если в дочерней саге есть вечный watcher (while (true)), то all никогда не выполнится.

```
function* rootSaga() {
  yield all([
    someWatcherSaga,
    someWorkerSaga,
  ]);
}
```

(2)
> Этот способ гарантирует порядок запуска саг.  
> После запуска всех дочерних саг, рутовая сага останавливается, дочерние продолжают работу.  
> fork - не блокирующий эффект, код после выполнится.  
> Этот способ позволяет гибко манипулировать тасками (fork возвращает таску), модно cancel, join, etc.

```
function* rootSaga() {
  yield fork(saga1);
  yield fork(saga2);  // сколько саг столько и форков
}
```

(3)
> Комбинация первого и второго способа.  
> Способ даёт возможность работать с тасками, но ошибки в дочерних сагах не приведут к падению рутовой саги.

```
function* rootSage() {
  yield all([
    fork(saga1),
    fork(saga2),
  ]);
}
```

(4)
> Вместо fork можно использовать spawn, тогда ошибка не всплывёт до рута.  
> если при использовании spawn возникнет необработанная ошибка, то о ней никто не узнает.

```
function* rootSaga() {
  yield spawn(saga1);
  yield spawn(saga2);
}
```

(5)
```
function* rootSaga() {
  const sagas = [saga1, saga2];

  yield all(sagas.map(
    (saga) => {
      return spawn(
        function*() {
          while (true) {
            try {
              yield call(saga);  // этот блок перезапускает упавшую сагу
              break;
            } catch (error) {
              console.log(error);
            }
          }
        }
      );
    }
  ));
}
```

___

## Параллельный запуск саг. Race, all

> `race` и `all` - комбинаторы саг, используются для параллельного запуска (похоже на promise.race(all)).

> `race` - запускает саги параллельно, завершится когда выполнится первая сага, остальные будут отменены.  
> race удобно использовать для отмены запроса; если экшен отмены придёт раньше, то остальные саги (в том числе  
> с запросом) отменятся.

> `all` - эффект-комбинатор; ожидает выполнения всех переданных саг; результирующий массив будет содержать результаты  
> выполнения всех саг;  
> синтаксис такой же как у race - принимает саги объектом или массивом.

```
const [ data1, data2 ] = yield race([
  fetchData1(),
  fetchData2(),
  take(FETCH_CANCEL),
]);

// второй вариант
const { data1, data2 } = yield race({
  data1: fetchData1(),
  data2: fetchData2(),
});
```

___

## Select

> `select(selector)` - эффект для получения данных из store внутри саги.  
>   - `selector` - функция извлечения из стора  
> 
> Нужно избегать использования select внутри саги, в идеале сага должна быть независима от стора.  
> Селекторы обычно выносят в отдельный файл selectors.js.  
> Селекторы могут иметь сложную логику выбора, сортировки, и пр.

```
// вернёт весь store
// общую структуру стора можно увидеть в rootReducer файле
const data = yield select();

const posts = yield select((state) => state.posts);
```

___


