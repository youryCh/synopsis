> **CLI** - Command Line Interface; интерфейс командной строки (ещё есть GUI - Graphic User Interface).

> **WSL** - Windows System for Linux; позволяет использовать linux в windows.
>
> `wsl --install`

`date` - текущая дата.

`#` - комментирование.

`\ + enter` - многострочный ввод.

> **Bash** - Bourn-again-shell; командная оболочка Unix; соответствует POSIX-стандарту.

> **REPL** - Read-eval-print-loop; (чтение-выполнение-вывод результата-возврат к ожиданию ввода);  
> процесс интерактивной сессии; способ взаимодействия с юзером.

`pwd` - print working directory; текущая рабочая директория; (`echo $PWD` - тоже).

`CTRL+INSERT/SHIFT+INSERT` - copy/paste в bash.

> **Скрытые файлы/директории** начинаются с `.`

```
// структура команды
      ls     -a      /home
command | -f/--flag | argument
        |  option   |
```

```
// комбинирование опций
ls -a -l
ls -al
```

> **Длинные/короткие флаги** - (-v/--version); короткие используются в cli, длинные обычно в баш-скриптах, для читаемости.

> У флагов бывают свои аргументы:
```
// варианты передачи аргументов для флагов
say -o some.mp3
say -o 'some\ song.mp3'
say -o=some.mp3
```

> `pipe` -  `command1 | command2`; способ комбинирования программ; вывод одной программы поступает на вход следующей.

```
// пример пайпа
ls -a | sort -n  // вывод ls идёт сразу на вход sort
```

`man <command>` - manual; документация команды; запускает less пейджер.
  - навигация: 
    - `f` - forward; вперёд
    - `b` - backward; назад
    - `q` - quit; выход

___

`cd` - change directory; без аргументов перейдёт в домашнюю директорию; принимает относительный и абсолютный пути.

`cd Program\ files` - экранирование пробела в имени файла.

**Пути:**  
- **абсолютный** - от корня (/)
- **относительный** - относительно текущей директории
- `..` - директория уровнем выше
- `.` - текущая директория
- `~` - домашняя директория
- `-` - предыдущая директория

___

`ls` - list; показать содержание директории.
  - `-l` - дополнительная информация (права доступа)
  - `-a` - скрытые файлы/директории
  - `-t` - sort by time (newest-first)
  - `-A` - скрытые файла но без `..` и `.`
  - `width` - указать ширину вывода

___

`sort` - сортировка
  - `-n` - by number

___

## Файловая структура

> В unix-системах **файловая структура** - это дерево с одним кормен (/), в отличии от windows, где каждый диск  
> это отдельное дерево со своим корнем.

`stat <file/dir>` - status; информация о файле/директории.

> **Имена файлов:**  
> - в win и mac - регистронезависимы
> - в nix - регистрозависимы (index.html != Index.html)

> В nix - всё файл (на нижнем уровне), и директория и диск - всё файл.  
> В nix **нет расширения** файла, точка является именем файла.  
> Точка в начале имени файла/директории делает его **скрытым**.

> **FHS** - Filesystem Hierarchy Standard; стандарт файловой структуры в Unix.

**Стандартные директории:**
- `/etc` - (et cetera - и т.д.); конфиги программ
- `/etc/hosts` - привязка хостов
- `/home` - домашняя директория юзера
- `/bin` - основные утилиты
- `/boot` - загрузочные файлы
- `/dev` - файлы устройств
- `/lib` - основные библиотеки
- `/media` - точки монтирования новых устройств
- `/opt` - дополнительное ПО
- `/root` - домашняя директория рут-юзера
- `/usr` - данные юзера
- `/var` - изменяемые (временные) файлы
- `/var/log` - основные логи
- `/var/log/syslog` - основные логи linux
- `/mnt` - доступ в win-файлам из WSL

**Основные типа файлов:**
- Hard Link - дополнительное для существующего файла
- Symbolic Link - как ярлык в win
- Socket - файл, через который идёт взаимодействие между процессами ОС

___

## Чтение файлов

`cat` - чтение файла.

`head` - чтение первых 10 строк.
  - `-n` - количество строк

`tail` - последние 10 строк.
  - `-n` - количество строк
  - `-f` - режим ожидания; захватывает управление (`CTRL+C` - выход)

```
// выведет 2 последние строки в режиме ожидания/обновления
tail -f -n 2 syslog
```

> **Пейджер** - программа просмотра с постраничном режиме.

`less` - пейджер; загружает только видимую в окне часть документа;  
- навигация: `f/b/q`
- поиск: 
    - `/` и ввести текст для поиска и `enter`
    - `n` - следующее совпадение
    - `N` - предыдущее
    - `space` - скролл на 1 окно

`more` - самый примитивный пейджер с поэкранным просмотром.
  - `space` - промотать на 1 экран

___

## Grep

> **Грепать** - типа гуглить, но по файлам.

`grep <pattern> <file>` - global regular expression print; поиск совпадения по файлу/файлам.
  - `pattern` - искомая строка или regexp
  - `-A/--after-context` - сколько выводить строк после совпадения
  - `-B/--before-context` - сколько выводить строк до совпадения
  - `-C/--context` - до и после совпадения
  - `-r` - искать внутри директории и рекурсивно по всем сабдиректориям; вместо файла указать путь до директории
  - `-n` - добавить номер строки


```
// выведет все строки с 'aliases' в .bashrc
grep aliases .bashrc

// выведет по одной строке до и после совпадения
grep -C 1 alias .bashrc
```

___

`find <where> <what>` - утилита поиска файлов; позволяет применять действия к найденным файлам.
  - `-name` - искать по имени файла
  - `-print` - вывести на экран
  - `-regex <regex>` - искать через регулярку
  - `-type` - тип искомого
    - `f` - file
    - `d` - directory

```
// найти все файлы в корневой директории, имя которых начинается с 'my...'
find / -name 'my*'

// пример использования логического выражения
// -O - OR
// -a - AND
find . \(-name 'my*' -O -name 'qu*'\) - print

// пример с регуляркой
find . -type f -regex '\(my\|qu\).*'
```

## Редактирование файлов

Редакторы:  
- Nano
- Vim (default)
- nvim - более совершенный vim
- Vi
- Emacs

### Nano

```
nano .bashrc
```

`^` - означает CTRL

### Vim (improved vi)

```
vim .bashrc
```

**4 режима:**
1. **command/normal** - дефолтный режим; позволяет сёрфить файл, вносить изменения, искать, удалять текст
2. **insert** - edit mode; режим ввода с клавиатуры
3. **visual** - выделение текста
4. **cli** - режим командной строки

`gvim` - версия vim, открывается в виде отдельного оконного приложения.

`i` - insert; переход в режим редактирования

`ESC`, `CTRL+[` - выход из режима редактирования в режим command

`:` - переход в режим ввода команд

`:q` - quit

`:w` - save

`:wq` - сохранить и выйти

`:qa!` - выйти без сохранения (все файлы)

`:q!` - выйти без сохранения в текущем файле

**Навигация:**
- `hjkl` - основная навигация по строкам/символам
- `w` - на слово вперёд
- `W` - вперёд по пробелам
- `b` - назад на слово
- `B` - назад по пробелам
- `dd` - удалить строку
- `diw` - удалить слово под курсором
- `gg` - в начало документа
- `/` - начать поиск
- `r` - ожидает ввода символа, который заменит символ под курсором

## Streams

> При старте любой программы ОС связывает с ней 3 потока:  
> - stdin  (standard in)
> - stdout  
> - stderr

> Для языка программирования все потоки это файлы.

### STDOUT

`STDOUT` - поток вывода (например на экран).

**Перенаправление потока:**

`>` - берёт вывод команды команды слева и перенаправляет в файл справа (всегда rewrite).

`>>` - тоже, но добавляет в конец файла, без перезаписи.

```
// вывод команды ls перенаправить из терминала (по дефолту) в file (если его нет, то создаст 
// в текущей директории)
ls -a > file

// принимает строку и перенаправляет в file.txt
echo 'hi' > file.txt
```

`echo <string>` - отправляет string в STDOUT - по дефолту терминал.

### STDIN

`STDIN` - через него программа может получать данные на вход; по дефолту клавиатура.

`wc` - word count; выводит количество строк, букв, newline, byte.
 - `-c/--bytes`
 - `-l/--lines`
 - `-m/--chars`
 - `-w/--words`

```
// пример использования stdin
// содержимое file направляется в stdin команды wc
wc < file

// посчитает слова в file и перенаправит вывод в file2
wc -w < file > file2
```

### STDERR

`STDERR` - позволяет отделить нормальный вывод от ошибок (по дефолту - вывод ошибок в терминал).

> Перенаправить вывод STDERR через `>` нельзя, только STDOUT, но можно объединить потоки.

**Файловые дескрипторы:**
- `0` - stdin
- `1` - stdout
- `2` - stderr

`&` - указывает на таргет-поток

```
// 2 и 1 это файловые дескрипторы
// 2>&1 значит перенаправить STDERR в STDOUT поток
ls someDir > output 2>&1

// перенаправит ошибки в файл errLog
// >> чтобы не перетирать лог, а добавлять новую запись
cd wrongFile 2>>errLog

// перенаправить 1 и 2 потоки
ls someDir &> logFile

// тоже но не затирать лог, а добавлять записи с потоков 1 и 2
ls someDir &>> logFile
```

___

## Pipeline

> Позволяет последовательно соединить программы и пропускать данные сквозь них.  
> По сути пайплайн - цепочка фильтров преобразующих результат.

> Pipeline - основа философии Unix.

> Чтобы утилита поддерживала pipeline, она должна принимать данные через STDIN, и отдавать результат через STDOUT.

` | ` - pipe; указывает что надо передать поток STDOUT одного процесса в STDIN следующего процесса.

```
grep alias .bashrc | grep color
```
___

`uniq` - фильтрует по уникальности (убирает дубли).
  - `-u/--unique` - print only uniq lines
  - `-d` - print only duplicate lines
  - `-i` - ignore case
  - `-c` - count of occurrence

___

## File System

> Все нижеследующие утилиты принимают аргументом как имя файла, так и путь до файла.  
> Для создания/удаления нескольких файлов - перечислить через пробел.

`touch` - изначально для изменения timestamp файла, если файла нет, то будет создан; по факту используется для  
создания файлов.

`rm` - remove; удалить файл/директорию.
  - `-r` - рекурсивно удалить всё внутри директории (и саму директорию)
  - `-f` - force; игнорирует несуществующие файлы, запрос подтверждения, предупреждения
  - `-d/--dir` - remove empty dir
  - `-v/--verbose` - explain what is being done

> В nix нет команды переименования, делается через перемещение файла (mv).

`mv <old_name> <new_name>` - move; перемещение, но по факту переименование файла.
  - `-f/--force` - без запроса
  - `-n/--no-clobber` - не переписывать существующий файл
  - `-v` - explain message


`cp <file> <copy_name>` - copy files/directories.
  - `-r` - copy dir
  - `-n` - создаёт новый файл и копирует в него

`mkdir` - make directory; по дефолту не создаёт вложенных директорий.
  - `-p/--parents` - рекурсивно (для создания вложенных директорий)
  - `-v` - print message

```
mkdir dir1 dir2

// вложенные директории
mkdir -p dir1/dir2
```

`tree` - отображает структуру файлов в виде дерево; устанавливается отдельно
  - `-a` - hidden files
  - `-d` - only dir
  - `-f` - full path prefix for each line
  - `--gitignore` - using .gitignore for filtering
  - `-O <file>` - send output to file
  - `-t` - sort by timestamp
  - `-s` - size
  - `-D` - print last timestamp

## Environments

> Переменные окружения существуют в рамках запущенной сессии терминала;  
> нужны для настройки единого окружения для многих команд, скриптов.

`env` - показать текущие установленные переменные.  
`echo $ENV_NAME`

> При старте bash устанавливается определённый набор переменных (HOME, etc); для каждой вкладки терминала - свои.

```
// изменить переменную
HOME=/tmp
```

> Bash использует переменную HOME для `cd ` (без аргумента), для перехода в домашнюю директорию.

> Значение переменных окружения может быть:  
> - локальное  
> - глобальное

```
// локальное определение переменной, только для cd
HOME=/tmp cd

// глобальное определение переменной
HOME=/tmp

export HOME=/tmp
``` 

`export` - экспортирует для всего окружения (env, functions).
  - `-f` - для функций
  - `-n` - удаление наследованных переменных
  - `-p` - список всех экспортированных переменных

___

## History

`.bash_history` - история команд в домашней директории.

`HISTFILESIZE` - env-переменная; указывает какое количество команд хранить в .bash_history; если переменную удалить,  
то .bash_history растёт бесконечно.

`history` - удобно выводит содержимое .bash-history.
  - `<n>` - любое количество выводимых строк
  - `CTRL+R` - поиск по истории

`!<n>` - повторный запуск команды из истории под номером n.

`!!` - повторить последнюю команду.

> Удалить `.bash_history` - чтобы не палиться.

```
history | grep | ls

history | grep mkdir | tail -n 5
```

`fzf` - command line fuzzy finder; более удобный поиск по командной строке; устанавливается отдельно.

```
history | fzf
```

___

`free` - display amount of free/used memory.
  - `-b/--bytes`
  - `-k/--kibi`
  - `-m/--mebi`
  - `-g/--gibi`
  - `-t` - total column

___

## Users & Groups

> Любой процесс запускается от имени конкретного пользователя с определёнными правами.

> **group** - для общего доступа к шареному ресурсу.

`etc/passwd` - основное хранилище пользователей.

`/usr/sbin/nologin` - юзер который не может входить в систему.

`whoami` - показать текущего юзера.

> **UID** - user id  
>
> **GID** - group id
>
> **PID** - process id

`ps` - process status; отчёт о запущенных процессах.
  - `-e` - all processes, not only current
  - `aux` - все процессы под разными пользователями (вторая колонка - PID)
  - `-f` - more info
  - `auxf` - запущенные процессы в виде дерева (родительские процессы запускают дочерние)

`id` - показать uid/gid текущего пользователя.
  - `-g` - only gid
  - `-u` - only uid

```
// схема вывода в /etc/passwd
// : - разделитель

yuri:x:1000:1000:,,,:/home/yuri:/bin/bash

user:pass:UID:GID:info:home_dir:default_shell
```

`root` - super user; UID = 0; имеет все доступы к системе.

`top` - display Linux processes; interactive.  
tap:
- `h` - help  
- `d/s` - change refresh rate; 3s - default  
- `q` - quit  
- `k` - kill process; need PID then

___

## Sudo

`su` - запуск команды с подставленным другим user/group; если без аргументов то от root;  
*deprecated

`sudo` - substitute user and do; повышает права юзера до root (by default);  
указывается перед исполняемой командой; просит пароль.  
  - `-u <user>` - если нужно выполнить под юзером отличном от root
  - `-i` - запускает новую сессию с рут-правами внутри текущей; для выполнения нескольких команд из под root
    - `exit` - logout

> В Ubuntu sudo запоминает спрошенный пароль минут на 5.

`/etc/sudoers` - конфиг политик доступов sudo (смотреть man sudoers).

`visudo` - специальный редактор sudoers; вызывается без аргументов.

`sudoedit <file>` - редактирования файла от имени root.

___

`tee` - read from STDIN and write to file, if file doesn't exist, it is created;  
в основном используется с другими командами через pipeline  
- `-a` - append? not overwrite

```
echo 'hi!' | tee file
```

___

## Права доступа

> Права можно посмотреть для каждого файла например в `stat`, `ls -la` - крайняя правая колонка.

- `r` - read  
- `w` - write (and delete)  
- `x` - execute

> Права задаются для трёх типов юзеров:  
> - User (владелец)  
> - Group (юзеры входящие в ту же группу)  
> - Other  

```
     -rw-r--r--
- file|1 |2 |3 |
d dir |

1 - права владельца
2 - права группы владельца
3 - права остальных

// порядок всегда такой
```

> Права файла берутся из прав директории в которой он лежит.

> `x` для директории означает что можно перемещаться по директории, обращаться ко всем файлам к ней (если они имеют `r`).

> Если в директорию с `x` положить файл с `r`, то доступ к файлу будет;  
> если у директории нет `x`, а файл имеет `r`, то файл будет недоступен.  
>
> Для простого `ls` достаточно `r` прав у директории;  
> для `ls -l` нужны `x` права у директории.

### Цифровой способ описания прав

- 7 - `rwx` (111)  
- 6 - `rw-` (110)  
- 5 - `r-x` (101)
- 4 - `r--` (100)
- 3 - `-wx` (011)
- 2 - `-w-` (010)
- 1 - `--x` (001)
- 0 - никаких прав

```
755

7 - user | 5 - group | 5 - other
```

### Смена прав

`chown` - change file owner and group.
  - `-R` - рекурсивно изменит все вложенные файлы
  - `-c` - view changes

```
chown root ./file

chown :newgroup .file
```

`chmod` - изменить доступы через цифровой формат.

```
chmod 777 ./file

// добавить x к правам владельца
chmod +x script.py
```

___

## Package managers

> Используются для установки приложений.

**brew** - pm for MacOS.

**apt** - default pm for Ubuntu.

**package** - упакованная программа; `deb` - формат пакетов Ubuntu.

```
// установка pm в системную директорию
sudo apt install php
```

`apt install <package>` - установка пакета.
  - `remove` - удалить пакет
  - `search` - найти пакет

> apt использует локальный индекс пакетов, иногда его нужно обновлять вручную, если пакет не находится.

`sudo apt update` - update local index.

___

## Program executing

> **Программа** - исполняемый файл или набор файлов, один из который исполняемый (бинарник).

> При запуске команды, shell ищет исполняемый файл в переменной окружения PATH (первая подошедшая директория слева направо).

> **Бинарник** - исполняемый файл; обычно новые пакеты хранятся в `usr/local/bin`.

```
// пример простого бинарника; внутри файла echo 'hi'
./executable  // запуск
```

> Иногда бинарник лежит не там где надо, тогда запуск через `./<file>`.  
> Или менять PATH руками в файле `.bashrc` или `.profile` или `.bash_profile`.

`type <command>` - путь до исполняемого файла.

`which <command>` - то же самое.

`whereis <command>` - то же + source, manual.

___


