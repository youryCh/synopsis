## Некоторые паттерны в Javascript, React

> **Module** - в js реализован благодаря export/import;  
> `<script type="module">`  


> **Singleton** - один объект состояния используемый компонентами по ссылке (React.Context).

> **Proxy** - обёртка над объектом, которая перехватывает управление (например для валидации).

```
const userProxy = new Proxy(user, {
  get: (target, prop) => {...},
  set: (target, prop, value) => {...}
});
```

> **Observer** - создание зависимости один-ко-многим; многие (т.е. наблюдатели) оповещаются об  
> изменении одного.

> **Factory** - генерация разных объектов, функций.

> **Prototype** - позволяет уменьшать/расширять функциональность; используется в наследовании js.
___

### React

> **Container/Presentational** - отделение бизнес-логики от представления.

> **HOC** - расширение функционала компонента за счет оборачивания в другой компонент (Redux.connect, React.Context).

> **Render props** - передача дочернего компонента как пропа в родительский и вызвать в родительском  
> как `{ props.renderComp() }` в функции render.

> **Hook** - функция с помошью которой можем получить/изменить состояние методом жизненного цикла  
> компонента.

> **Provider** - компонент-обёртка, который шарит состояние со многими обёрнутыми компонентами;  
> позволяет избежать props drilling (Context provider).

> **Compound** - разделение на множество небольших компонентов, обёрнутых в один compound-компонент.
___

## Dependency Injection

> **Суть DI** - не привязываться к конкретной зависимости, а ожидать её извне.

> **Аналогия** - в ноуте встроенный дисплей это прямая зависимость, hdmi-порт - внешний интерфейс, изолированный от  
> конкретного монитора.

> **В программировании:**  
> вместо создания инстанса класса внутри класса, лучше передать его снаружи, избавив внешний класс от прямой зависимости.  
> А набор методов, предоставляемый инстансом, определить через интерфейс.  
> Класс не должен создавать экземпляр зависимого класса.

```
// прямая зависимость, большая связанность
class Today {
  day = new Date(),

  getDay() {
    return day.getDay();
  },
}

// with DI
class Today {
  constructor(day: Date) {  // набор предоставляемых методов определяем через интерфейс
    this.day = day
  }

  getDay() {
    return this.day.getDay();
  }
}

const today = new Today(new Date);
```

**Преимущества DI:**
- более независимый код
- более тестируемый
- легче расширять
- легче переиспользовать
___

## Fluent Interface

> Это паттерн проектирования в ООП стиле, направленный на улучшение читаемости кода;  
> по сути это вызов методов через `.` (как композиция функций в ФП);  
> может быть реализован как класс с **конечными** (возвращает результат) и **бесконечными** методами (возвращают `this`, что  
> даёт возможность вызывать через точку сколько угодно раз).

```
class Enumerable {
  constructor(collection) {
    this.collection = collection;
  }

  where(fn) {
    this.collection = this.collection.filter(fn);

    return this;   // пример бесконечного метода, за счёт возврата this
  }

  toArray() {  //  конечный метод
    return this.collection;
  }
}
```
___

## Singleton

**Singleton** - (одиночка) паттерн гарантирует что у класса будет только один экземпляр; т.е. инстанс создаётся раз, при  
попытке создать инстанс ещё раз, вернётся уже созданный; инстанс имеет глобальный доступ; применяется для конфигов  
(keycloak), подключении к бд, логирования, счётчики и прочие глобальный объекты.

```
// lazy singleton - создаёт инстанс только при обращении
class Singleton {
  private static _instance: Singleton;

  private constructor() {}

  static getInstance() {
    if (!Singleton._instance) Singleton._instance = new Singleton();

    return Singleton._instance;
  }
}
```

Синглтон часто можно заменить статическим классом.

***Недостатки:**
- нарушает SRP, т.к. помимо создания инстанса, контролирует его создание
- зависимость класса от синглтона не очевидна
- глобальное состояние
- сложность тестирования
___


