## Некоторые паттерны в Javascript, React

> **Module** - в js реализован благодаря export/import;  
> `<script type="module">`  


> **Singleton** - один объект состояния используемый компонентами по ссылке (React.Context).

> **Proxy** - обёртка над объектом, которая перехватывает управление (например для валидации).

```
const userProxy = new Proxy(user, {
  get: (target, prop) => {...},
  set: (target, prop, value) => {...}
});
```

> **Observer** - создание зависимости один-ко-многим; многие (т.е. наблюдатели) оповещаются об  
> изменении одного.

> **Factory** - генерация разных объектов, функций.

> **Prototype** - позволяет уменьшать/расширять функциональность; используется в наследовании js.

### React

> **Container/Presentational** - отделение бизнес-логики от представления.

> **HOC** - расширение функционала компонента за счет оборачивания в другой компонент (Redux.connect, React.Context).

> **Render props** - передача дочернего компонента как пропа в родительский и вызвать в родительском  
> как `{ props.renderComp() }` в функции render.

> **Hook** - функция с помошью которой можем получить/изменить состояние методом жизненного цикла  
> компонента.

> **Provider** - компонент-обёртка, который шарит состояние со многими обёрнутыми компонентами;  
> позволяет избежать props drilling (Context provider).

> **Compound** - разделение на множество небольших компонентов, обёрнутых в один compound-компонент.

___

## Dependency Injection

> **Суть DI** - не привязываться к конкретной зависимости, а ожидать её извне.

> **Аналогия** - в ноуте встроенный дисплей это прямая зависимость, hdmi-порт - внешний интерфейс, изолированный от  
> конкретного монитора.

> **В программировании:**  
> вместо создания инстанса класса внутри класса, лучше передать его снаружи, избавив внешний класс от прямой зависимости.  
> А набор методов, предоставляемый инстансом, определить через интерфейс.  
> Класс не должен создавать экземпляр зависимого класса.

```
// прямая зависимость, большая связанность
class Today {
  day = new Date(),

  getDay() {
    return day.getDay();
  },
}

// with DI
class Today {
  constructor(day: Date) {  // набор предоставляемых методов определяем через интерфейс
    this.day = day
  }

  getDay() {
    return this.day.getDay();
  }
}

const today = new Today(new Date);
```

**Преимущества DI:**
- более независимый код
- более тестируемый
- легче расширять
- легче переиспользовать

___


