> **Docker** - программа; позволяет ОС запускать процессы в изолированном окружении не базе специально созданных  
> образов.

> Используется для доставки приложения на машины (пк/сервер) и запуска в изолированном окружении.

> **Daemon** - фоновый процесс linux (в win демоны называются службы); не привязан к терминалу в котором запущен.

`init` - (PID 1) корневой процесс linux; создаётся при запуске системе; все другие процессы - его потомки;  
запускает всех необходимых демонов (`/etc/init.d/`).

> Имена демонов заканчиваются на `d` (например systemd).

**Установка** - смотри [doc](https://docs.docker.com/get-docker/)

> **Image** - образ, слепок файловой системы; содержит приложение (PostgreSQL, nginx, etc или разрабатываемое  
> приложение).  
>
> Это файловая система, которая формируется на базе команд dockerfile;  
> каждый образ формируется из первоначального образа scratch.

> **Container** - это процесс ОС, подключенный к файловой системе образа; обычно каждый контейнер это атомарный сервис.

> **Registry** - хранилище докер-образов.

> **User image** - если имя образа с префиксом через `/`; **official** поддерживаемые Docker образы - без `/`.

```
lodash/getting-started   //  user image

nginx                    //  official
```

### Запуск контейнера

`docker run <image_name> <command> <-flags, params>` - запуск контейнера; при первом запуске скачивает нужный образ.
  - `-it` - интерактивный режим, нужен для программ ожидающих пользовательский ввод  
  - `-e <ENV="env">` - проброс значения в переменную окружения (пример на ENV)  
  - `-p <external port>:<internal port>` - проброс портов  
  - `-d` - демонизация приложения (запуск в фоновом режиме); вернёт id контейнера для использования в docker stop  
  - `--restart` :  
    - `on-failure` - перезапуск контейнера в случае ошибки (по дефолту не перезапускается)  
    - `always` - перезапуск всегда (даже если docker stop)  
    - `unless-stopped` - всегда перезапускать, кроме docker stop
  - `--name=Name` - задать имя контейнера при старте  
  - `--read-only` - запрещает любую запись внутри контейнера  
  - `-v <файл_на_хосте>:<файл_в_контейнере>` - проброс файлов  
  - `--user <id>` - для запуска собственного контейнера  
  - `-w` - working dir inside the container

```
// запустить баш внутри контейнера (с правами root), используя образ nginx

docker run -it nginx bash
```

```
// обращение к файлу внутри образа из наружи контейнера

docker run nginx cat /etc/nginx/nginx.conf
```

```
// запуск nginx контейнера

docker run -p 8080:80 nginx

// 8080:80 - проброс портов
// после nginx не указана команда, т.к. она прописана в самом образе (это обычно для образов со стандартный запусков)
```

> Docker требует от каждого образа выводить логи в STDOUT (что хорошо для масштабирования - не хранить/обрабатывать).

> Перезапуск контейнеров обычно делает Kubernetes или Systemd.

> **Проброс портов** - механизм связи внутреннего и наружного портов; нужен т.к. сеть внутри контейнера изолирована.

```
-p 3000:3001   // 3000 - порт который выставляем наружу
               // 3001 - порт через который можем попасть внутрь контейнера
```

### Переменные окружения

> Задаются либо на уровне системы, либо при запуске приложения; это требуются т.к. контейнер изолирован от  
> внешнего окружения.

```
// явный проброс env переменных
// переменных может быть любое количество (каждый раз через -e)

-e NAME='Anna'
```

___

`docker stop <container_id>` - остановить контейнер.

`docker ps` - список запущенный контейнеров.
  - `-a` - all

`docker images` - список скаченных образов;

`tag` - версия образа; по дефолту - latest (обычно не указывается).

```
docker run nginx:latest   // latest по соглашению последний, но не факт
```

> Для прода надёжнее брать версии названные по семверу (типа 1.0.0), остальные могут меняться (1 может быть 1.1.1 или 1.2.0).

`docker pull <image>` - обновление версии образа, если доступно; при run версия не проверяется на свежесть.

`docker rmi <image>` - delete image.
  - `-f` - force

`docker logs <id|name>` - выведет текущий лог и выйдет.
  - `-f` - watch режим

`docker ps` - инфо о запущенных контейнерах.
  - `-a`

Содержит:  
- `CONTAINER_ID` - id (short hash)  
- `IMAGE` - имя образа, из которого поднят контейнер; если не указан тег, то latest  
- `COMMAND` - команда старта контейнера  
- `CREATED` - время создания контейнера  
- `STATUS` - текущее состояние  
- `PORTS` - проброс портов  
- `NAMES` - алиас

**Exit status codes:**  
- `exited (0)` - exited success
- `125` - container failed to run
- `127` - file/dir not found
- `137` - immediate termination (SIGKILL)
- `255` - out of range (unknown error)

```
// команда выполнится в контейнере и завершится

docker run ubuntu ls
```

**Container lifecycle:**
- `created` - created but not started yet
- `up` - running
- `paused` - was running, paused
- `exited`

`docker stop <id|name>` - остановить контейнер; отправляет сигнал SIGTERM;  
остановка не удаляет контейнер, можно перезапустить.

`docker start <id|name>` - запускает остановленный контейнер, всегда в фоновом режиме.

`docker kill <id|name>` - гарантированно остановит и удалит контейнер; отправляет SIGKILL; (не удалит образ).

## Сеть

> Сетевое приложение стартует на каком-то интерфейсе с указанием порта (по дефолту 127.0.0.1:3000 - localhost:3000).

> Внутри контейнера свой localhost!

> Запуск сервера внутри контейнера должен выполняться на адресе 0.0.0.0

`0.0.0.0` - специальная маска; указывает ОС подключиться к каждому доступному интерфейсу в системе.

> Docker создаёт специальный интерфейс с ip-адресом внутри каждого контейнера, через него реализует выход наружу.  
> Докер требует явного указания порта, который нужно указать наружу.

```
docker run -p 8080:3000   // внешний порт 8080 свяжи с портом 3000 внутри контейнера
                          // т.е. снаружи стучать в 8080
```

```
// явное указание ip
docker run -p 127.0.0.1:8080:3000  // сервис будет доступен на localhost
                                   // без такого указания будет 0.0.0.0 - любой доступный сетевой интерфейс
```

```
// проброс нескольких портов

docker run -p 80:80 -p 443:443 nginx
```

## Шаринг данных

**Docker app бывает:**
- stateless - без хранения состояния
- stateful - использует данные файловой системы

> Важно придерживаться правила неизменяемости контейнера, данные должны сохраняться наружу.

**Шаринг данных между контейнерами** - пробросить директорию в нужное количество контейнеров, которые будут туда  
писать/читать (типа общий кеш).

```
docker run -v /tmp:/tmp nginx
```

**Правила путей:**
- путь на хосте может быть и относительный и абсолютный
- путь внутри контейнера - только абсолютный
- если файл/директория не существуют внутри контейнера, то будут созданы автоматически

```
// обмен данными с хост-системой
// делает доступной историю внутри контейнера
// т.е. история команд будет писаться во внешний файл

docker run -it -v $HOME/.bash_history:/root/.bash_history ubuntu bash
```

`$HOME` - переменная окружения с домашней директорией юзера (/home/yuri), то же что `~`.

> Через `-v` можно пробрасывать любое количество файлов.

```
// проброс всей директории

docker run -it -v /etc/nginx:/etc/nginx nginx
```

**Ошибки нейминга** - если ошибиться в названии файла на хост-машине, докер просто создаст новый.

## Собственный образ

> Содержит код приложения и все зависимости.

```
// запуск npm команды из node контейнера; результат положит в path_to_file

docker run --user $(id -u) -w /out -v /path_to_file:/out node npm init fastify

// path_to_file - заранее проверить через pwd
// $(id -u) - проброс user id
```

```
// npm install

docker run -it -w /out -v `pwd`:/out node npm install
```

`docker build -t <name> .` - сборка образа на основе dockerfile.
  - `-t/--tag` - имя образа и тег (latest по дефолту)  
  - `.` - контекст
  - `--no-cache` - не кешировать сборку

___

## Dockerfile

> Docker создаёт образ на основе dockerfile.

`docker login` - авторизация.

**Загрузка образа на хаб:**
- создать пустой репозиторий
- `docker push yuriche/example:tagname`

> Dockerfile состоит из команд; каждая последующая команда видит результат выполнения предыдущей.

### Команды

`FROM` - первая команда; задаёт образ, чья файловая система берётся за основу.

```
FROM node:20
```

`WORKDIR` - задаёт рабочую директорию, относительно которой выполняются действия во время формирования образа  
и при входе в контейнер.

```
// создаст директорию если её нет

WORKDIR /app
```

`COPY <что> <куда>` - копирует файлы/директории из хоста внутрь образа.  
`<что>` - файл/директория; `.` - копировать текущую директорию целиком.  
`<куда>` - и под каким именем; 3 варианта указания:  
- абсолютный путь
- относительный (от WORKDIR)
- `.` - копировать как есть в источнике

```
COPY package.json .

// то же что

COPY package.json package.json
```

```
// копировать все файлы внутрь

COPY . .
```

**Контекст** - это директория, относительно которой работает первый параметр COPY;  
обычно контекстом указывают директорию с dockerfile.

```
docker build -t my/image .

// . - это контекст, т.е. текущая директория, к которой dockerfile и из которой запускается build
```

```
// здесь контекст - директория уровнем выше

docker build some ..
```

> Во время сборки контекст копируется внутрь системной директории Docker, из которой в образ переносится  
> всё что указано в команде COPY.

`.dockerignore` - содержит то что не должно стать частью контекста (node_modules, .git).

`RUN` - выполняет переданную строку в терминале от имени root.

> Через RUN вносятся основные изменения в файловую систему, добавляются пакеты, зависимости, и тп.

```
RUN apt-get install -q curl

// -q - ставить автоматически без вопросов
```

```
// если базовый образ Ubuntu, то доступна apt

RUN apt-get update && apt-get install -q curl

RUN npm install
```

`CMD` - задаёт команду которая выполняется контейнером по умолчанию; используется если контейнер запущен  
без команды.

`ENV` - задаёт переменные окружения; команды после ENV видят эти переменные и могут использовать.

> В dockerfile обычно фиксируют переменные не зависящие от окружения и среды запуска.
> Обычно переменные окружения указываются при запуске контейнера.

___

## Слои

**OverlayFS** - внутри файловой системы докер; использует слои.

**Слой** - файловая структура, получившаяся в результате выполнения RUN.

`dpkg` - Debian package manager (Debian - один из дистрибутивов linux).

`docker diff <image_id>` - покажет изменения сделанные в рамках работы с контейнером (открыть в другом окне).

> Docker кеширует слои для оптимизации, чтобы не кешировать указать флаг `--no-cache`, либо менять имя внутри  
> dockerfile для сброса кеша.

```
docker build --no-cache

# dockerfile
ENV VERSION 1
```

___

## Docker Compose

> **Docker Compose** - является частью докера; для управления набором контейнеров, каждый из которых это один  
> сервис проекта.

`docker-compose.yml` - конфиг проекта с сервисами.

**Команды:**
- `docker compose up` - сборка образов и запуск с учётом конфига.
  - `-d` - в фоне
- `docker compose build` - для повторной сборки
- `docker compose run` - запуск сервиса
- `docker compose down` - останавливает и удаляет сервисы запущенные через `up`
- `docker compose stop` - останавливает но не удаляет сервисы
- `docker compose start` - запуск остановленных сервисов
- `docker compose restart` - перезапуск всех сервисов

___


