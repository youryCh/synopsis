**Сравнение строк** в js - посимвольное.

```
'bbb' < 'c';  // true
```
___

**Ленивое вычисление** логических выражений:

`||` вернёт первое true значение или последнее, если все false.

```
alert(undefined || null || 0);  // 0

const user1 = undefined;
const user2 = 'Anna';
const curUser = user1 || user2 || 'unnamed';  // типа значение по умолчанию, если все юзеры == false
const curUser2 = user1 || !user2 || '';  // хотя '' == false, возьмёт последнее значение
```

`&&` вернёт первое false значение или последнее, если все true.

```
alert(1 && 2 && null && 3);  // null

1 && 2 && 3;  // 3
```
___

`!!` - первое логическое НЕ сначала приводит к булеву типу и инвертирует, второе НЕ ещё раз инвертирует.
___

**Приоритеты логических операторов:**
1. `!` (NOT)  
2. `&&` (AND)  
3. `||` (OR)
___

`??` - nullish coalescing; проверка на null, undefined.

```
// Зачем придумали?

const height = 0;

alert(height || 100);  // 100, хотя 0 - валидное значение и дефолтное не надо применять
alert(height ?? 100);  // 0
```

`??` имеет низкий приоритет, часто нужны скобки.

```
// без скобок может быть NaN
const area = (height ?? 100) * (width ?? 50);
```

`??` нельзя использовать вместе с `||` или `&&`, будет синтаксическая ошибка. Можно обойти используя скобки.

```
1 && 2 ?? 3  // SyntaxError

(1 && 2) ?? 3  // 2
```
___

`for (;;)` - бесконечный цикл.

**Метки** - позволяют использовать break/continue для указанного цикла.

```
outerLoop: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (j === 2) break outerLoop;  // прервёт внешний цикл с меткой
  }
}
```

Метки работают только внутри цикла.  

`break` - прерывает цикл.

`continue` - прерывает текущую итерацию, но не цикл.
___

Пустой return или если нет return, то функция возвращает `undefined`.  

И **function** declaration и function expression (когда присваиваем анонимную функцию переменной) одинаково  
создают переменную и содержат там значение функции.

В js функция это значение, его можно присвоить другой переменной.

```
const foo = (a, b) => a + b;

const bar = foo;  // присвоен не результат вызова foo, а само значение функции
```
___

**callback** - функция которая передаётся как аргумент для последующего вызова.

**Function expression** создаётся когда выполнение кода доходит до него.  

**Function declaration** парсится движком до выполнения скрипта. Поэтому Fd можно вызывать до объявления её самой.
___

`debugger;` - устанавливает breakpoint, работает только при открытом devtools.
___

```
// кнопка в Source Devtools; останавливает выполнение скрипта на ошибках.
/----\
| II |
\----/ 
```
___

## Тесты

1 тест проверяет 1 кейс.  
Если в `it(test)` описать несколько проверок, то не будет понятно какая упала.  

`beforeEach/afterEach`, `before/after` - обычно используются для инициализации, обнуления счётчиков.
___

## Object

Объект может иметь свойство из нескольких слов, тогда обращение через `[]`.

```
const obj = {'two words': 123};

obj['two words'];
```

Обращение через `.` требует чтобы ключ именовался по правилу для переменных (кроме зарезервированных слов).

Обращение через `[]` также позволяет использовать выражение в качестве ключа.
___

**Ключи** другого типа кроме string, автоматически приводятся к строке.
___

Обращение к несуществующему свойству вернёт undefined.
___

`in` - оператор, проверяет наличие ключа в объекте.

```
alert('name' in obj);
```
___

`for in` - цикл для перебора ключей объекта.

```
for (let key in obj) {
  alert(key);
  alert(obj[key]);
}
```
___

**Порядок ключей:**
- свойства с целочисленными значениями сортируются по возрастанию  
- остальные в порядке создания

```
for (let key in {'3': 'three', '1': 'one'}) {
  alert(key);  // 1, 3
}
```
___

**object** - в JS это ассоциативный массив с дополнительными возможностями.

**Ключи** - могут быть типа string, symbol.

`delete` - оператор удаления свойства объекта.

```
delete obj.name;
```
___

Переменная хранит не сам объект, а ссылку на его расположение в памяти.

При простом копировании, копируется ссылка а не сам объект.
___

`Object.assign(dist, src1, ...srcN)` для клонирования одноуровневого объекта; клонирует в dest все перечисленные следом  
объекты; совпадающие значения затираются новыми.

Вложенные объекты можно клонировать через `for in` или `_.cloneDeep()` из lodash.
___

**Сборщик мусора** - фоновый auto process движка, удаляет недостижимые объекты.

**Недостижимые** - объекты на которые никто не ссылается и они нигде не используются.

Алгоритм сборщика идёт от корня и помечает объекты, на которые идёт ссылка, все не помеченные объекты удаляются.

Оптимизация сборки:
- generation collection - делит объекты на новые/старые
- incremental collection - поэтапно, чтобы избежать одной долгой задержки
- idle-time collection - сборка во время простоя CPU
___

**Метод** - функция которая является свойством объекта.
___

## this

`this` вычисляется во время выполнения кода и зависит от контекста вызова.

Если внутри функции используется this, обычно ожидается что функция будет вызываться в контексте объекта.

**this в JS** - свободный, т.е. вычисляется в ходе выполнения. В других языках this фиксированный - указывает на свой объект.

**this в методах объекта** - для доступа к информации внутри этого объекта.

**this в функции** == undefined в Strict mode, в нестрогом window (исторически сложившееся поведение).

**У стрелочных** функций нет своего this, берёт из внешней функции.
___

**Constructor** и оператор `new` позволяют создавать однотипные объекты.
___

**Constructor** - это просто функция названная с большой буквы (по соглашению) и вызывается через `new`.

Технически любую функцию можно вызвать через `new` (кроме стрелок).
___

**Алгоритм при при вызове через new:**

```
function User(name) {
  this = {};  // неявно
  this.name = name;
  return this;  // неявно
}
```
___

Сложный объект можно создать с помощью **анонимной функции constructor:**

```
const user = new function() {  // конструктор одноразовый, т.к. анонимный
  this.name = 'Anna';
  ...
}
```
___

`new.target` - (внутри конструктора) вернёт саму функцию, если вызвана через new, иначе undefined.
___

Если в конструктор не передаются аргументы, то `()` можно не писать.

```
new Date;
```
___

`?.` - опциональная цепочка; вернёт undefined, если часть перед `?` == null/undefined, и прекращает все дальнейшие  
вычисления и вызовы.

```
user.getName?.();  // если getName не существует, вызова не будет

user?.['1'];

delete user?.name;  // удалит если user существует
```

`?.` нельзя использовать в левой части присваивания.
___

## Symbol


