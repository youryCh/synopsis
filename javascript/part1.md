**Сравнение строк** в js - посимвольное.

```
'bbb' < 'c';  // true
```
___

**Ленивое вычисление** логических выражений:

`||` вернёт первое true значение или последнее, если все false.

```
alert(undefined || null || 0);  // 0

const user1 = undefined;
const user2 = 'Anna';
const curUser = user1 || user2 || 'unnamed';  // типа значение по умолчанию, если все юзеры == false
const curUser2 = user1 || !user2 || '';  // хотя '' == false, возьмёт последнее значение
```

`&&` вернёт первое false значение или последнее, если все true.

```
alert(1 && 2 && null && 3);  // null

1 && 2 && 3;  // 3
```
___

`!!` - первое логическое НЕ сначала приводит к булеву типу и инвертирует, второе НЕ ещё раз инвертирует.
___

**Приоритеты логических операторов:**
1. `!` (NOT)  
2. `&&` (AND)  
3. `||` (OR)
___

`??` - nullish coalescing; проверка на null, undefined.

```
// Зачем придумали?

const height = 0;

alert(height || 100);  // 100, хотя 0 - валидное значение и дефолтное не надо применять
alert(height ?? 100);  // 0
```

`??` имеет низкий приоритет, часто нужны скобки.

```
// без скобок может быть NaN
const area = (height ?? 100) * (width ?? 50);
```

`??` нельзя использовать вместе с `||` или `&&`, будет синтаксическая ошибка. Можно обойти используя скобки.

```
1 && 2 ?? 3  // SyntaxError

(1 && 2) ?? 3  // 2
```
___

`for (;;)` - бесконечный цикл.

**Метки** - позволяют использовать break/continue для указанного цикла.

```
outerLoop: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (j === 2) break outerLoop;  // прервёт внешний цикл с меткой
  }
}
```

Метки работают только внутри цикла.  

`break` - прерывает цикл.

`continue` - прерывает текущую итерацию, но не цикл.
___

Пустой return или если нет return, то функция возвращает `undefined`.  

И **function** declaration и function expression (когда присваиваем анонимную функцию переменной) одинаково  
создают переменную и содержат там значение функции.

В js функция это значение, его можно присвоить другой переменной.

```
const foo = (a, b) => a + b;

const bar = foo;  // присвоен не результат вызова foo, а само значение функции
```
___

**callback** - функция которая передаётся как аргумент для последующего вызова.

**Function expression** создаётся когда выполнение кода доходит до него.  

**Function declaration** парсится движком до выполнения скрипта. Поэтому Fd можно вызывать до объявления её самой.
___

`debugger;` - устанавливает breakpoint, работает только при открытом devtools.
___

```
// кнопка в Source Devtools; останавливает выполнение скрипта на ошибках.
/----\
| II |
\----/ 
```
___

## Тесты

1 тест проверяет 1 кейс.  
Если в `it(test)` описать несколько проверок, то не будет понятно какая упала.  

`beforeEach/afterEach`, `before/after` - обычно используются для инициализации, обнуления счётчиков.
___

## Object

Объект может иметь свойство из нескольких слов, тогда обращение через `[]`.

```
const obj = {'two words': 123};

obj['two words'];
```

Обращение через `.` требует чтобы ключ именовался по правилу для переменных (кроме зарезервированных слов).

Обращение через `[]` также позволяет использовать выражение в качестве ключа.
___

**Ключи** другого типа кроме string, автоматически приводятся к строке.
___

Обращение к несуществующему свойству вернёт undefined.
___

`in` - оператор, проверяет наличие ключа в объекте.

```
alert('name' in obj);
```
___

`for in` - цикл для перебора ключей объекта.

```
for (let key in obj) {
  alert(key);
  alert(obj[key]);
}
```
___

**Порядок ключей:**
- свойства с целочисленными значениями сортируются по возрастанию  
- остальные в порядке создания

```
for (let key in {'3': 'three', '1': 'one'}) {
  alert(key);  // 1, 3
}
```
___

**object** - в JS это ассоциативный массив с дополнительными возможностями.

**Ключи** - могут быть типа string, symbol.

`delete` - оператор удаления свойства объекта.

```
delete obj.name;
```
___

Переменная хранит не сам объект, а ссылку на его расположение в памяти.

При простом копировании, копируется ссылка а не сам объект.
___

`Object.assign(dist, src1, ...srcN)` для клонирования одноуровневого объекта; клонирует в dest все перечисленные следом  
объекты; совпадающие значения затираются новыми.

Вложенные объекты можно клонировать через `for in` или `_.cloneDeep()` из lodash.
___

**Сборщик мусора** - фоновый auto process движка, удаляет недостижимые объекты.

**Недостижимые** - объекты на которые никто не ссылается и они нигде не используются.

Алгоритм сборщика идёт от корня и помечает объекты, на которые идёт ссылка, все не помеченные объекты удаляются.

Оптимизация сборки:
- generation collection - делит объекты на новые/старые
- incremental collection - поэтапно, чтобы избежать одной долгой задержки
- idle-time collection - сборка во время простоя CPU
___

**Метод** - функция которая является свойством объекта.
___

## this

`this` вычисляется во время выполнения кода и зависит от контекста вызова.

Если внутри функции используется this, обычно ожидается что функция будет вызываться в контексте объекта.

**this в JS** - свободный, т.е. вычисляется в ходе выполнения. В других языках this фиксированный - указывает на свой объект.

**this в методах объекта** - для доступа к информации внутри этого объекта.

**this в функции** == undefined в Strict mode, в нестрогом window (исторически сложившееся поведение).

**У стрелочных** функций нет своего this, берёт из внешней функции.
___

**Constructor** и оператор `new` позволяют создавать однотипные объекты.
___

**Constructor** - это просто функция названная с большой буквы (по соглашению) и вызывается через `new`.

Технически любую функцию можно вызвать через `new` (кроме стрелок).
___

**Алгоритм при при вызове через new:**

```
function User(name) {
  this = {};  // неявно
  this.name = name;
  return this;  // неявно
}
```
___

Сложный объект можно создать с помощью **анонимной функции constructor:**

```
const user = new function() {  // конструктор одноразовый, т.к. анонимный
  this.name = 'Anna';
  ...
}
```
___

`new.target` - (внутри конструктора) вернёт саму функцию, если вызвана через new, иначе undefined.
___

Если в конструктор не передаются аргументы, то `()` можно не писать.

```
new Date;
```
___

`?.` - опциональная цепочка; вернёт undefined, если часть перед `?` == null/undefined, и прекращает все дальнейшие  
вычисления и вызовы.

```
user.getName?.();  // если getName не существует, вызова не будет

user?.['1'];

delete user?.name;  // удалит если user существует
```

`?.` нельзя использовать в левой части присваивания.
___

## Types

Примитив хранит одно значение примитивного типа, а объект хранит множество значений как свойства.

Примитивы имеют свои **объекты-обёртки** (String, Boolean, Number, Symbol).  
При вызове метода у примитива, создаётся такой объект-обёртка, запускается метод, возвращается результат,  
обёртка удаляется.

```
// метод конструктора String
'name'.toUpperCase();  

// конструкторы String, Number, Boolean не стоит вызывать через new
typeof new String('str');  // object
```

`null, undefined` - самые примитивные, не имеют обёрток и методов.
___

## Symbol

`Symbol` - уникальный идентификатор.

Symbol и string только могут быть ключами в объекте.

```
// id - имя/описание символа
// два символа с одним и тем же именем не будут равны
const id = Symbol('id');

id.description;  // 'id'
id.toString();  // 'Symbol(id)'
```
___

**Symbol позволяет** создавать скрытые свойства объекта, доступные только из кода где создан символ.
___

Symbol в литерале объекта пишется через `[]`.

```
const id = Symbol('id');
const obj = {
  [id]: 123,
};
```
___

**Symbol не перебирается** в `for in`, `Object.keys()`, но `Object.assign()` копирует символы.
___

**Глобальный реестр символов** - пространство где можно создать многоразовые символы.

`Symbol.for(key)` - получить или создать, если такого нет, символ из реестра.

**Глобальные символы** - доступны везде.

`Symbol.keyFor(Symbol)` - принимает глобальный символ и возвращает его имя или undefined (то же что метод  
`description` для не глобальных символов).

`Reflect.ownKeys(obj)`  
`Object.getOwnPropertySymbols(obj)` - возвращают все свойства, в т.ч. с ключами-символами.  
___

## Number

```
const million = 1e6;  // e указывает количество нулей

const ms = 1e-6;  // 0.000001 (6 нулей)

123e-2 == 1.23
```
___

`0x` - шестнадцатеричные числа (`0xff` == 255).

`0o` - восьмеричные числа (`0o377` == 255).

`0b` - двоичные (бинарные) числа (`0b11111111` == 255).
___

`num.toString(base)` - строковое представление числа по указанному основанию; base = 10 по дефолту.

```
const num = 255;

num.toString(16);  // ff

// так не работает
255.toString();  // SyntaxError, потому что первая точка ожидает ввода дробной части

// а так норм
255.0.toString();
255..toString();
(255).toString();
```
___

Округления:
- `Math.floor()` - в меньшую сторону.
- `Math.ceil()` - в большую сторону.
- `Math.round()` - математическое округление.
- `Math.trunc()` - отбросит дробную часть.
- `num.toFixed(n)` - округление до n знаков после запятой; если n не указан, то отбросит всю дробную часть; делает  
  математическое округление; возвращает string.  
- `num.toPrecision(n)` - вернёт строковое представление числа; n - количество знаков всего; округляет математически.

```
Math.floor(1.9);  // 1
Math.ceil(1.1);  // 2
Math.round(1.5);  // 2
Math.trunc(1.99);  // 1

(1.99).toFixed();  // '2' - отбросит дробную часть с математическим округлением
(1.19999).toFixed(2);  // '1.20'
(44).toFixed(2);  // '44.00'

(1.999).toPrecision();  // '1.999'
(1.999).toPrecision(2);  // '2.0'
(44).toPrecision(4);  // '44.00'
```
___

Число в JS хранится в 64-битном формате:
- 52 бита - для цифр
- 11 бит - положение десятичной точки
- 1 бит - для знака
___

**Неточность вычислений в JS** - причина в двоичном представлении десятичного числа.

`IEEE-754` - стандарт формата числа в JS.

Например 0.1 в двоичном представлении будет бесконечной дробью, которая округляется, что и приводит к неточности.

Также происходит округление когда не хватает бит для хранения числа.

```
console.log(9999999999999999);  // 10000000000000000
```
___

В JS есть `0` и `-0`, их отличия игнорируются операторами сравнения.
___

`Infinity` `-Infinity` `NaN` - относятся к типу number.

`isNaN` - проверка на NaN, т.к. NaN не равен ни чему, даже самому себе.

`isFinite()` - вернёт true для любого числа, но false - для NaN, Infinity, -Infinity.

```
NaN === NaN;  // false

Object.is(NaN, NaN);  // true
```
___

`Object.is(value1, value2)` - Метод сравнения как `===`, кроме двух кейсов:

```
Object.is(NaN, NaN);  // true, === вернёт false

Object.is(0, -0);  // false, === вернёт true
```
___

`parseInt(string, [base])`  
`parseFloat(string, [base])` - парсят число (число с запятой) из строки типа `'10px'`; base - опциональное основание.

```
parseInt('12.5px');  // 12 - отбрасывает все после запятой
parseFloat('12.5px');  // 12.5
parseInt('$12');  // NaN
parseInt('0xffgg', 16);  // 255  треш типа gg отбросит
```
___

При работе с дробями, числа в JS теряют точность, нельзя использовать операторы сравнения в лоб.
___

## String

`UTF-16` - внутренний формат строк.
___

`for (let char of 'string') {}` - можно перебирать строку.
___

```
'Hey you!'.includes('you');  // true
```
___

`startsWith()`  
`endsWith()` - проверяет начинается/заканчивается ли строка подстрокой, указанной в аргументе.

```
'hi'.startsWith('h');  // true
```
___

**Получение подстроки:**  
- `slice(start, end)` - взять подстроку от start до end (не включая end); можно использовать отрицательные значения.
- `substring(start, end)` - между start и end; отрицательное значение == 0.
- `substr(start, length)` - (old method) length символов начиная от start; start может быть отрицательным.
___

**Сравнение строк:**  
- Строки сравниваются посимвольно в алфавитном порядке.
- Маленькая буква больше заглавной.
- Диакритические знаки (ё) идут не по порядку первыми.
___

`codePointAt(idx)` - вернёт unicode символа на позиции idx.

`String.fromCodePoint()` - вернёт строку созданную из указанной последовательности кодов.

`str.localCompare(str2)` - правильное сравнение строк с учётом языка окружения.

`String.fromCharCode()`  
`charCodeAt()` - то же что методы выше, но устаревшие (не работают с суррогатными парами).

**Суррогатная пара** - редкие символы, записываются двумя 16-битными кодовыми единицами.
___

**Диакритические знаки** - специальные знаки над/под буквами (типа ё).

`s\u0307` - пример unicode диакритического знака.

`str.normalize(form)` - нормализация символов с диакритическими знаками (например для корректного сравнения);  
form - определяет форму нормализации (NFC, NFD, NFKC, NFKD).
___

`str.trim()` - убирает пробелы в начале/конце строки.

`str.repeat(n)` - повторяет строку n раз.
___

`\u2026` - **многоточие** одним символом.
___

## Array

**Очередь** - упорядоченная коллекция элементов, поддерживающая 2 вида операций:  
- `push` - добавить элемент в конец
- `shift` - удалить элемент в начале, сдвигая очередь влево.

**Стек** - структура данных, поддерживающая операции:  
- `push` - добавить элемент в конец
- `pop` - удалить последний элемент

**Двусторонняя очередь** - может как стек и очередь; по сути это и есть массив в JS.
___

`push`, `unshift` - добавить элемент (или несколько через запятую) в конец/начало массива.

`pop`, `shift` - удалить последний/первый элемент массива; возвращает сам удалённый элемент.
___

**Массив в JS** - упорядоченная структура данных с числовым индексом; относится к типу object, расширяет его  
специальными свойствами и методами.

Массив копируется по ссылке, т.к. это object.

Массив эффективен только если содержит упорядоченный данные (т.е. индекс по порядку от 0).

Массиву можно присвоить свойство с нечисловым ключом; движок будет работать с таким массивом как с объектом и не  
будут работать специфические методы массива.

```
const arr = [];

arr.name = 'Anna';
```
___

`push, pop` - **быстрые**, `shift, unshift` - **медленные**, т.к. при работе с началом массива, нужно изменять все индексы.
___

`for of` - цикл for с сокращённым синтаксисом для перебора массива.
___

`for in` - также можно использовать для массива, но он медленный и перебирает все свойства, в т.ч. с нечисловым ключом.
___

`length` - содержит не длину, а последний числовой индекс элемента + 1.

```
const arr = [];

arr[100] = 'sto';
arr.length;  // 101
```

`length` можно переназначить, т.е. если length назначить число меньше длины массива, то элемент с конца невозвратно  
удалится.

`arr.length = 0;` - простой способ очистить массив.
___

`new Array(5)` - создаст новый массив с length = 5, с пустыми значениями.
___

Массив можно привести к строке через String:

```
String([1, 2, 3]);  // '1,2,3'
```
___

`slice()` - без аргументов делает **копию массива**.
___

`concat(arg)` - создаёт новый массив, в который копирует данные из переданных массивов + дополнительные аргументы.

```
[1, 2].concat([3, 4]);  // [1, 2, 3, 4]
```
___

`sort()` - без функции сравнения в аргументе сортирует в лексиграфическом порядке (т.е. элементы приводятся к строке  
и сравниваются как строки).

Для функции сравнения достаточно вернуть любое положительное/отрицательное число.

```
[2, 1].sort((a, b) => a - b);
```
___

`reduce` - если нет initial, в качестве него берётся первый элемент, и перебор начинается со второго, НО если массив  
окажется пустым, то будет ошибка (это если нет initial, если есть, то reduce пустого массива вернёт initial).

`reduceRight` - то же что reduce, но перебор справа налево.
___

`Array.isArray()` - проверка является ли массивом; `typeof []` вернёт object, ибо массив в JS не является отдельным типом.
___

`find(fn, thisArg)` - почти у всех методов массива есть второй опциональный параметр - **this**.
___

`arr.some(fn)`  
`arr.every(fn)` - если callback-функция для какого-либо/всех элементов вернёт true, то метод вернёт true, иначе false.
___

`arr.fill(value, start, end)` - заполнит массив одинаковыми элементами от start до end (не включая end);  
заполнит весь массив если без start, end.

```
[1, 2, 3, 4].fill(0, 2, 4);  // [1, 2, 0, 0]
```
___

`arr.copyWithin(target, start, end)` - копирует элементы между start и end и вставляет начиная с индекса target.

```
[1, 2, 3, 4, 5].copyWithin(0, 2, 4);  // [3, 4, 3, 4, 5]
```
___

## Iterable objects

**Итерируемые объекты** - реализуют метод `Symbol.iterator`.

`Symbol.iterator` - скрыто есть у любого итерируемого объекта (string, array, map, set);  
содержит метод `next()`.

`next()` - возвращает объект {done: boolean, value: any}.

```
// пример явного вызова итератора
const iterator = 'string'[Symbol.iterator]();

while (true) {
  const res = iterator.next();

  if (res.done) break;

  console.log(res.value);
}
```

**Псевдомассивы** - объекты с цифровыми индексами (свойствами) и есть свойство length.

```
const arrayLike = {
  0: 'hello',        // числовой ключ приводится к строке
  1: 'world',
  length: 2,
};
```
___

`Array.from(arrayLike, [mapFn, thisArg])` - делает массив из итерируемого объекта/псевдомассива;  
mapFn - обрабатывает каждый элемент.
___

## Map Set

**Map** -  коллекция ключ-значение, но использует ключи любого типа;  
имеет встроенные методы:  
- `.set(key, value)`
- `.get(key)`
- `.has(key)`
- `.delete(key)`
- `.clear()`
- `.size`

Можно использовать объекты как ключи.
___

`.set()` - возвращает изменённый map, поэтому вызов можно объединить в цепочку.

```
map.set(...)
  .set(...)
  .set(...)
```
___

**Методы перебора:**
- `map.keys()` - возвращает итерируемый объект ключей.
- `map.values()` - возвращает итерируемый объект значений.
- `map.entries()` - возвращает итерируемый объект `[key, value]`.
- `map.forEach()`
___

Для **создания map** используется массив пар ключ-значение.

```
const map = new Map([
  ['1', 'value'],
  [1, 'value'],
  [true, 'value'],
]);
```
___

```
// сделать map из объекта
new Map(Object.entries(obj));

// объект из map
Object.fromEntries(map);
```
___

**Set** - коллекция уникальных значений без ключей (аля массив).

`new Set(arr)` - создаёт set из итерируемого объекта (массива, строки и пр).

**Методы:**
- `set.add(value)` - добавить value (добавит если оно уникально); возвращает изменённый set.
- `set.delete(value)` - удалить; возвращает boolean.
- `set.has(value)` - проверить наличие value; возвращает boolean.
- `set.clear()`
- `set.size`
- `set.values()` - итерируемый объект значений.
- `set.keys()` - то же что `.values()`; для совместимости с map.
- `set.entries()` - вернёт объект `[value, value]`; для совместимости с map.
- `set.forEach((value, value, set) => {})` - два value для совместимости с тем же методом у map.
___

```
const set = new Set([1, 2, 1]);  // [1, 2]

const set2 = new Set('gggfff');  // ['g', 'f']

let set = new Set('hi all hi all'.split(' '));  // ['hi', 'all']
```
___

Set перебирается через `forEach`, `for of`.
___

```
// функция возвращает массив уникальных значений
const uniq = (arr) => Array.from(new Set(arr));
```
___

## WeakMap WeakSet

**WeakMap** - подобна Map, но ключи могут быть только объекты.

**WeakSet** - подобна Set, но хранит только объекты.
___

WeakMap/WeakSet удаляет данные как только объект (в качестве ключа в WeakMap) становится недостижимым вне коллекции.  
Т.е. если на объект нет ссылок вне WeakMap/WeakSet, то значение потрётся сборщиком мусора JS.
___

Обе структуры не поддерживают свойства и методы для всего содержимого, т.к. оно неопределённо в разное время.

`keys(), values(), entries(), forEach(), for of, size` - не работают.
___

**Используются** в основном как дополнительные хранилища к основному, типа как кеш.

Иначе:  
Если объект больше не используется в основном коде, то он (и связанные с ним значения) автоматически удалятся из  
Weak структуры.

Map и Set хранят данные постоянно.
___

`keys()`  
`values()`  
`entries()` - методы есть у Map, Set, Array; возвращают итерируемый объект.

`Object.keys()`  
`Object.values()`  
`Object.entries()` - такие же методы для простого объекта; игнорирует Symbols; возвращают массив; сделаны как статические  свойства Object, т.к. в объекте может содержатся свойство keys.

`Object.getOwnPropertySymbols()` - вернёт массив символов.

`Reflect.ownKeys(obj)` - вернёт все ключи с символами.
___

Как использовать **методы массива на объекте:**
1. `Object.entries(obj)`
2. `map/filter/etc`
3. `Object.fromEntries(arr)`

```
Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, value * 2]));
```
___

## Destructuring assignment

```
// пример деструктурирующего присваивания
const [name, surname] = 'Anna Karenina'.split(' ');

const [first,, third] = arr;
```
___

**Деструктуризация работает с любым итерируемым объектом**

```
const [a, b, c] = 'abc';

const [one, two, three] = new Set([1, 2, 3]);
```
___

```
// присваивание объекту
let user = {};

[user.name, user,surname] = arr;
```
___

```
// деструктуризация с Object.entries()
for (let [key, value] of Object.entries(obj)) {...}

// то же с Map
for (let [k, v] of userMap) {...}
```
___

**rest параметры** - остаточные параметры при дестракте массива.

```
// rest - массив остатков
const [first, second, ...rest] = arr;
```
___

```
// пустые значения
const [one, two] = [];

one;  // undefined
two;  // undefined
```
___

**Значения по умолчанию**

```
const [one = 1, two = getTwo()] = arr;

// getTwo() выполнится только если нет второго элемента в arr
```
___

**rest параметры для объектов**

```
const {name, ...rest} = obj;

rest;  // {} с остатками
```
___

При **деструктуризации сложных структур** левая сторона должна повторять структуру правой.
___

## Date

**timestamp** - целое число миллисекунд с 01.01.1970; даты до 1970 - отрицательное значение; UTC+0.

**UTC** - Coordinated Universal Time; всемирное координированное время.
___

`new Date()` - без аргументов это текущая дата.

`new Date(100)` - вернёт объект Date с преобразованной из 100 мс датой.

`new Date('2022-10-01')` - вернёт объект Date указанной даты (формат даты может быть через тире, точку, запятую, пробел).

`new Date(year, month, day, hours, min, sec, ms)` - создаст объект Date с заданными параметрами; обязательный только  
первые два (тогда остальные будут = 0, day = 1).
___

**Январь - 0** месяц, декабрь - 11.  

**Воскресенье - 0** день, суббота - 6.
___

**Методы:**
- `getFullYear()`
- `getMonth()`
- `gatDate()` - вернёт день (1-31)
- `getHours()`
- `getMinutes()`
- `getSeconds()`
- `getMilliseconds()`
- `gatDay()` - вернёт день недели от 0 (вс) до 6 (сб)

Все эти методы возвращают значение в местном часовом поясе.
___

Чтобы получить значение даты **по UTC** (т.е. 0 часовой пояс), нужно подставить `UTC` после `get`:

- `getUTCFullYear()`
- `getUTCMonth()`
- etc

`getTime()` - для заданной даты возвращает timestamp (мс с 1 января 1970 UTC+0).

`getTimezoneOffset()` - вернёт разницу в минутах между UTC и локальным временем.

```
new Date().getTimezoneOffset();  // -180 для Мск
```
___

`new Date().toLocaleString(locale, options)` - форматирует дату в местном представлении.
___

**Методы установки даты:**
- `setFullYear()`
- `setMonth()`
- и так далее, но вместо get - set

Также для всех set-методов (кроме setTime(ms)) есть UTC вариант - `setUTCFullYear()` и т.д.

```
// текущая дата, но время 00:00:00
new Date().setHours(0, 0, 0, 0);

// текущая дата с нужным офсетом времени
new Date().setSeconds(new Date().getSeconds() + 20);
```
___

**Автоисправление в Date:**

```
new Date(2022, 0, 32);  // 1 feb 2022
```
___

**Приведение к числу:**

```
Number(new Date());  // число в мс, то же что getTime()
```
___

`date.toISOString()` - ISO 8601 формат даты (`YYYY-MM-DDTHH:mm:ss.sssZ`), где `T` - разделитель, `Z` - (опционально)  
часовой пояс в формате `+-hh:mm`, или просто `Z` - будет UTC+0.
___

**Вычисление разности дат:**

```
const start = new Date();

someHardCalcFunction();

const end = new Date();

console.log(end - start);  // оператор минут приведёт Date к числу мс
                           // но лучше использовать performance.now()
```
___

`Date.now()` - вернёт timestamp; тоже что `new Date().getTime()`, но быстрее, т.к. не создаёт объект Date.
___

`Date.parse(string)` - возвращает timestamp из строки формата `YYYY-MM-DDTHH:mm:ss.sssZ`
___

`performance.now()` - часть браузерного API; вернёт мс с начала загрузки страницы; но можно использовать более точного  
вычисления разности между двумя вызовами.

`microtime` - модуль nodeJS для timestamp.
___

**Последнее число месяца:**

```
new Date(2022, 10 + 1, 0).getDate();

// день передаётся в диапазоне 1-31, 0 это последний день предыдущего месяца
// месяц +1 т.к. 0 день вернёт к предыдущему месяцу
```
___

## JSON


