**Сравнение строк** в js - посимвольное.

```
'bbb' < 'c';  // true
```
___

**Ленивое вычисление** логических выражений:

`||` вернёт первое true значение или последнее, если все false.

```
alert(undefined || null || 0);  // 0

const user1 = undefined;
const user2 = 'Anna';
const curUser = user1 || user2 || 'unnamed';  // типа значение по умолчанию, если все юзеры == false
const curUser2 = user1 || !user2 || '';  // хотя '' == false, возьмёт последнее значение
```

`&&` вернёт первое false значение или последнее, если все true.

```
alert(1 && 2 && null && 3);  // null

1 && 2 && 3;  // 3
```
___

`!!` - первое логическое НЕ сначала приводит к булеву типу и инвертирует, второе НЕ ещё раз инвертирует.
___

**Приоритеты логических операторов:**
1. `!` (NOT)  
2. `&&` (AND)  
3. `||` (OR)
___

`??` - nullish coalescing; проверка на null, undefined.

```
// Зачем придумали?

const height = 0;

alert(height || 100);  // 100, хотя 0 - валидное значение и дефолтное не надо применять
alert(height ?? 100);  // 0
```

`??` имеет низкий приоритет, часто нужны скобки.

```
// без скобок может быть NaN
const area = (height ?? 100) * (width ?? 50);
```

`??` нельзя использовать вместе с `||` или `&&`, будет синтаксическая ошибка. Можно обойти используя скобки.

```
1 && 2 ?? 3  // SyntaxError

(1 && 2) ?? 3  // 2
```
___

`for (;;)` - бесконечный цикл.

**Метки** - позволяют использовать break/continue для указанного цикла.

```
outerLoop: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (j === 2) break outerLoop;  // прервёт внешний цикл с меткой
  }
}
```

Метки работают только внутри цикла.  

`break` - прерывает цикл.

`continue` - прерывает текущую итерацию, но не цикл.
___

Пустой return или если нет return, то функция возвращает `undefined`.  

И **function** declaration и function expression (когда присваиваем анонимную функцию переменной) одинаково  
создают переменную и содержат там значение функции.

В js функция это значение, его можно присвоить другой переменной.

```
const foo = (a, b) => a + b;

const bar = foo;  // присвоен не результат вызова foo, а само значение функции
```
___

**callback** - функция которая передаётся как аргумент для последующего вызова.

**Function expression** создаётся когда выполнение кода доходит до него.  

**Function declaration** парсится движком до выполнения скрипта. Поэтому Fd можно вызывать до объявления её самой.
___

`debugger;` - устанавливает breakpoint, работает только при открытом devtools.
___

```
// кнопка в Source Devtools; останавливает выполнение скрипта на ошибках.
/----\
| II |
\----/ 
```
___

## Тесты

1 тест проверяет 1 кейс.  
Если в `it(test)` описать несколько проверок, то не будет понятно какая упала.  

`beforeEach/afterEach`, `before/after` - обычно используются для инициализации, обнуления счётчиков.
___

## Object

Объект может иметь свойство из нескольких слов, тогда обращение через `[]`.

```
const obj = {'two words': 123};

obj['two words'];
```

Обращение через `.` требует чтобы ключ именовался по правилу для переменных (кроме зарезервированных слов).

Обращение через `[]` также позволяет использовать выражение в качестве ключа.
___

**Ключи** другого типа кроме string, автоматически приводятся к строке.
___

Обращение к несуществующему свойству вернёт undefined.
___

`in` - оператор, проверяет наличие ключа в объекте.

```
alert('name' in obj);
```
___

`for in` - цикл для перебора ключей объекта.

```
for (let key in obj) {
  alert(key);
  alert(obj[key]);
}
```
___

**Порядок ключей:**
- свойства с целочисленными значениями сортируются по возрастанию  
- остальные в порядке создания

```
for (let key in {'3': 'three', '1': 'one'}) {
  alert(key);  // 1, 3
}
```
___

**object** - в JS это ассоциативный массив с дополнительными возможностями.

**Ключи** - могут быть типа string, symbol.

`delete` - оператор удаления свойства объекта.

```
delete obj.name;
```
___

Переменная хранит не сам объект, а ссылку на его расположение в памяти.

При простом копировании, копируется ссылка а не сам объект.
___

`Object.assign(dist, src1, ...srcN)` для клонирования одноуровневого объекта; клонирует в dest все перечисленные следом  
объекты; совпадающие значения затираются новыми.

Вложенные объекты можно клонировать через `for in` или `_.cloneDeep()` из lodash.
___

**Сборщик мусора** - фоновый auto process движка, удаляет недостижимые объекты.

**Недостижимые** - объекты на которые никто не ссылается и они нигде не используются.

Алгоритм сборщика идёт от корня и помечает объекты, на которые идёт ссылка, все не помеченные объекты удаляются.

Оптимизация сборки:
- generation collection - делит объекты на новые/старые
- incremental collection - поэтапно, чтобы избежать одной долгой задержки
- idle-time collection - сборка во время простоя CPU
___

**Метод** - функция которая является свойством объекта.
___

## this

`this` вычисляется во время выполнения кода и зависит от контекста вызова.

Если внутри функции используется this, обычно ожидается что функция будет вызываться в контексте объекта.

**this в JS** - свободный, т.е. вычисляется в ходе выполнения. В других языках this фиксированный - указывает на свой объект.

**this в методах объекта** - для доступа к информации внутри этого объекта.

**this в функции** == undefined в Strict mode, в нестрогом window (исторически сложившееся поведение).

**У стрелочных** функций нет своего this, берёт из внешней функции.
___

**Constructor** и оператор `new` позволяют создавать однотипные объекты.
___

**Constructor** - это просто функция названная с большой буквы (по соглашению) и вызывается через `new`.

Технически любую функцию можно вызвать через `new` (кроме стрелок).
___

**Алгоритм при при вызове через new:**

```
function User(name) {
  this = {};  // неявно
  this.name = name;
  return this;  // неявно
}
```
___

Сложный объект можно создать с помощью **анонимной функции constructor:**

```
const user = new function() {  // конструктор одноразовый, т.к. анонимный
  this.name = 'Anna';
  ...
}
```
___

`new.target` - (внутри конструктора) вернёт саму функцию, если вызвана через new, иначе undefined.
___

Если в конструктор не передаются аргументы, то `()` можно не писать.

```
new Date;
```
___

`?.` - опциональная цепочка; вернёт undefined, если часть перед `?` == null/undefined, и прекращает все дальнейшие  
вычисления и вызовы.

```
user.getName?.();  // если getName не существует, вызова не будет

user?.['1'];

delete user?.name;  // удалит если user существует
```

`?.` нельзя использовать в левой части присваивания.
___

## Types

Примитив хранит одно значение примитивного типа, а объект хранит множество значений как свойства.

Примитивы имеют свои **объекты-обёртки** (String, Boolean, Number, Symbol).  
При вызове метода у примитива, создаётся такой объект-обёртка, запускается метод, возвращается результат,  
обёртка удаляется.

```
// метод конструктора String
'name'.toUpperCase();  

// конструкторы String, Number, Boolean не стоит вызывать через new
typeof new String('str');  // object
```

`null, undefined` - самые примитивные, не имеют обёрток и методов.
___

## Symbol

`Symbol` - уникальный идентификатор.

Symbol и string только могут быть ключами в объекте.

```
// id - имя/описание символа
// два символа с одним и тем же именем не будут равны
const id = Symbol('id');

id.description;  // 'id'
id.toString();  // 'Symbol(id)'
```
___

**Symbol позволяет** создавать скрытые свойства объекта, доступные только из кода где создан символ.
___

Symbol в литерале объекта пишется через `[]`.

```
const id = Symbol('id');
const obj = {
  [id]: 123,
};
```
___

**Symbol не перебирается** в `for in`, `Object.keys()`, но `Object.assign()` копирует символы.
___

**Глобальный реестр символов** - пространство где можно создать многоразовые символы.

`Symbol.for(key)` - получить или создать, если такого нет, символ из реестра.

**Глобальные символы** - доступны везде.

`Symbol.keyFor(Symbol)` - принимает глобальный символ и возвращает его имя или undefined (то же что метод  
`description` для не глобальных символов).

`Reflect.ownKeys(obj)`  
`Object.getOwnPropertySymbols(obj)` - возвращают все свойства, в т.ч. с ключами-символами.  
___

## Number

```
const million = 1e6;  // e указывает количество нулей

const ms = 1e-6;  // 0.000001 (6 нулей)

123e-2 == 1.23
```
___

`0x` - шестнадцатеричные числа (`0xff` == 255).

`0o` - восьмеричные числа (`0o377` == 255).

`0b` - двоичные (бинарные) числа (`0b11111111` == 255).
___

`num.toString(base)` - строковое представление числа по указанному основанию; base = 10 по дефолту.

```
const num = 255;

num.toString(16);  // ff

// так не работает
255.toString();  // SyntaxError, потому что первая точка ожидает ввода дробной части

// а так норм
255.0.toString();
255..toString();
(255).toString();
```
___

Округления:
- `Math.floor()` - в меньшую сторону.
- `Math.ceil()` - в большую сторону.
- `Math.round()` - математическое округление.
- `Math.trunc()` - отбросит дробную часть.
- `num.toFixed(n)` - округление до n знаков после запятой; если n не указан, то отбросит всю дробную часть; делает  
  математическое округление; возвращает string.  
- `num.toPrecision(n)` - вернёт строковое представление числа; n - количество знаков всего; округляет математически.

```
Math.floor(1.9);  // 1
Math.ceil(1.1);  // 2
Math.round(1.5);  // 2
Math.trunc(1.99);  // 1

(1.99).toFixed();  // '2' - отбросит дробную часть с математическим округлением
(1.19999).toFixed(2);  // '1.20'
(44).toFixed(2);  // '44.00'

(1.999).toPrecision();  // '1.999'
(1.999).toPrecision(2);  // '2.0'
(44).toPrecision(4);  // '44.00'
```
___

Число в JS хранится в 64-битном формате:
- 52 бита - для цифр
- 11 бит - положение десятичной точки
- 1 бит - для знака
___

**Неточность вычислений в JS** - причина в двоичном представлении десятичного числа.

`IEEE-754` - стандарт формата числа в JS.

Например 0.1 в двоичном представлении будет бесконечной дробью, которая округляется, что и приводит к неточности.

Также происходит округление когда не хватает бит для хранения числа.

```
console.log(9999999999999999);  // 10000000000000000
```
___

В JS есть `0` и `-0`, их отличия игнорируются операторами сравнения.
___

`Infinity` `-Infinity` `NaN` - относятся к типу number.

`isNaN` - проверка на NaN, т.к. NaN не равен ни чему, даже самому себе.

`isFinite()` - вернёт true для любого числа, но false - для NaN, Infinity, -Infinity.

```
NaN === NaN;  // false

Object.is(NaN, NaN);  // true
```
___

`Object.is(value1, value2)` - Метод сравнения как `===`, кроме двух кейсов:

```
Object.is(NaN, NaN);  // true, === вернёт false

Object.is(0, -0);  // false, === вернёт true
```
___

`parseInt(string, [base])`  
`parseFloat(string, [base])` - парсят число (число с запятой) из строки типа `'10px'`; base - опциональное основание.

```
parseInt('12.5px');  // 12 - отбрасывает все после запятой
parseFloat('12.5px');  // 12.5
parseInt('$12');  // NaN
parseInt('0xffgg', 16);  // 255  треш типа gg отбросит
```
___

При работе с дробями, числа в JS теряют точность, нельзя использовать операторы сравнения в лоб.
___

## String

`UTF-16` - внутренний формат строк.
___

`for (let char of 'string') {}` - можно перебирать строку.
___

```
'Hey you!'.includes('you');  // true
```
___

`startsWith()`  
`endsWith()` - проверяет начинается/заканчивается ли строка подстрокой, указанной в аргументе.

```
'hi'.startsWith('h');  // true
```
___

**Получение подстроки:**  
- `slice(start, end)` - взять подстроку от start до end (не включая end); можно использовать отрицательные значения.
- `substring(start, end)` - между start и end; отрицательное значение == 0.
- `substr(start, length)` - (old method) length символов начиная от start; start может быть отрицательным.
___

**Сравнение строк:**  
- Строки сравниваются посимвольно в алфавитном порядке.
- Маленькая буква больше заглавной.
- Диакритические знаки (ё) идут не по порядку первыми.
___

`codePointAt(idx)` - вернёт unicode символа на позиции idx.

`String.fromCodePoint()` - вернёт строку созданную из указанной последовательности кодов.

`str.localCompare(str2)` - правильное сравнение строк с учётом языка окружения.

`String.fromCharCode()`  
`charCodeAt()` - то же что методы выше, но устаревшие (не работают с суррогатными парами).

**Суррогатная пара** - редкие символы, записываются двумя 16-битными кодовыми единицами.
___

**Диакритические знаки** - специальные знаки над/под буквами (типа ё).

`s\u0307` - пример unicode диакритического знака.

`str.normalize(form)` - нормализация символов с диакритическими знаками (например для корректного сравнения);  
form - определяет форму нормализации (NFC, NFD, NFKC, NFKD).
___

`str.trim()` - убирает пробелы в начале/конце строки.

`str.repeat(n)` - повторяет строку n раз.
___

`\u2026` - **многоточие** одним символом.
___

## Array

**Очередь** - упорядоченная коллекция элементов, поддерживающая 2 вида операций:  
- `push` - добавить элемент в конец
- `shift` - удалить элемент в начале, сдвигая очередь влево.

**Стек** - структура данных, поддерживающая операции:  
- `push` - добавить элемент в конец
- `pop` - удалить последний элемент

**Двусторонняя очередь** - может как стек и очередь; по сути это и есть массив в JS.
___

`push`, `unshift` - добавить элемент (или несколько через запятую) в конец/начало массива.

`pop`, `shift` - удалить последний/первый элемент массива; возвращает сам удалённый элемент.
___

**Массив в JS** - упорядоченная структура данных с числовым индексом; относится к типу object, расширяет его  
специальными свойствами и методами.

Массив копируется по ссылке, т.к. это object.

Массив эффективен только если содержит упорядоченный данные (т.е. индекс по порядку от 0).

Массиву можно присвоить свойство с нечисловым ключом; движок будет работать с таким массивом как с объектом и не  
будут работать специфические методы массива.

```
const arr = [];

arr.name = 'Anna';
```
___

`push, pop` - **быстрые**, `shift, unshift` - **медленные**, т.к. при работе с началом массива, нужно изменять все индексы.
___

`for of` - цикл for с сокращённым синтаксисом для перебора массива.
___

`for in` - также можно использовать для массива, но он медленный и перебирает все свойства, в т.ч. с нечисловым ключом.
___

`length` - содержит не длину, а последний числовой индекс элемента + 1.

```
const arr = [];

arr[100] = 'sto';
arr.length;  // 101
```

`length` можно переназначить, т.е. если length назначить число меньше длины массива, то элемент с конца невозвратно  
удалится.

`arr.length = 0;` - простой способ очистить массив.
___

`new Array(5)` - создаст новый массив с length = 5, с пустыми значениями.
___

Массив можно привести к строке через String:

```
String([1, 2, 3]);  // '1,2,3'
```
___

`slice()` - без аргументов делает **копию массива**.
___

`concat(arg)` - создаёт новый массив, в который копирует данные из переданных массивов + дополнительные аргументы.

```
[1, 2].concat([3, 4]);  // [1, 2, 3, 4]
```
___


