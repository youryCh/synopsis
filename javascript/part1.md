**Сравнение строк** в js - посимвольное.

```
'bbb' < 'c';  // true
```
___

**Ленивое вычисление** логических выражений:

`||` вернёт первое true значение или последнее, если все false.

```
alert(undefined || null || 0);  // 0

const user1 = undefined;
const user2 = 'Anna';
const curUser = user1 || user2 || 'unnamed';  // типа значение по умолчанию, если все юзеры == false
const curUser2 = user1 || !user2 || '';  // хотя '' == false, возьмёт последнее значение
```

`&&` вернёт первое false значение или последнее, если все true.

```
alert(1 && 2 && null && 3);  // null

1 && 2 && 3;  // 3
```
___

`!!` - первое логическое НЕ сначала приводит к булеву типу и инвертирует, второе НЕ ещё раз инвертирует.
___

**Приоритеты логических операторов:**
1. `!` (NOT)  
2. `&&` (AND)  
3. `||` (OR)
___

`??` - nullish coalescing; проверка на null, undefined.

```
// Зачем придумали?

const height = 0;

alert(height || 100);  // 100, хотя 0 - валидное значение и дефолтное не надо применять
alert(height ?? 100);  // 0
```

`??` имеет низкий приоритет, часто нужны скобки.

```
// без скобок может быть NaN
const area = (height ?? 100) * (width ?? 50);
```

`??` нельзя использовать вместе с `||` или `&&`, будет синтаксическая ошибка. Можно обойти используя скобки.

```
1 && 2 ?? 3  // SyntaxError

(1 && 2) ?? 3  // 2
```
___

`for (;;)` - бесконечный цикл.

**Метки** - позволяют использовать break/continue для указанного цикла.

```
outerLoop: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (j === 2) break outerLoop;  // прервёт внешний цикл с меткой
  }
}
```

Метки работают только внутри цикла.  

`break` - прерывает цикл.

`continue` - прерывает текущую итерацию, но не цикл.
___

Пустой return или если нет return, то функция возвращает `undefined`.  

И **function** declaration и function expression (когда присваиваем анонимную функцию переменной) одинаково  
создают переменную и содержат там значение функции.

В js функция это значение, его можно присвоить другой переменной.

```
const foo = (a, b) => a + b;

const bar = foo;  // присвоен не результат вызова foo, а само значение функции
```
___

**callback** - функция которая передаётся как аргумент для последующего вызова.

**Function expression** создаётся когда выполнение кода доходит до него.  

**Function declaration** парсится движком до выполнения скрипта. Поэтому Fd можно вызывать до объявления её самой.
___

`debugger;` - устанавливает breakpoint, работает только при открытом devtools.
___

```
// кнопка в Source Devtools; останавливает выполнение скрипта на ошибках.
/----\
| II |
\----/ 
```
___
___
## Тесты

1 тест проверяет 1 кейс.  
Если в `it(test)` описать несколько проверок, то не будет понятно какая упала.  

`beforeEach/afterEach`, `before/after` - обычно используются для инициализации, обнуления счётчиков.
___
___
## Object

Объект может иметь свойство из нескольких слов, тогда обращение через `[]`.

```
const obj = {'two words': 123};

obj['two words'];
```

Обращение через `.` требует чтобы ключ именовался по правилу для переменных (кроме зарезервированных слов).

Обращение через `[]` также позволяет использовать выражение в качестве ключа.
___

**Ключи** другого типа кроме string, автоматически приводятся к строке.
___

Обращение к несуществующему свойству вернёт undefined.
___

`in` - оператор, проверяет наличие ключа в объекте.

```
alert('name' in obj);
```
___

`for in` - цикл для перебора ключей объекта.

```
for (let key in obj) {
  alert(key);
  alert(obj[key]);
}
```
___

**Порядок ключей:**
- свойства с целочисленными значениями сортируются по возрастанию  
- остальные в порядке создания

```
for (let key in {'3': 'three', '1': 'one'}) {
  alert(key);  // 1, 3
}
```
___

**object** - в JS это ассоциативный массив с дополнительными возможностями.

**Ключи** - могут быть типа string, symbol.

`delete` - оператор удаления свойства объекта.

```
delete obj.name;
```
___

Переменная хранит не сам объект, а ссылку на его расположение в памяти.

При простом копировании, копируется ссылка а не сам объект.
___

`Object.assign(dist, src1, ...srcN)` для клонирования одноуровневого объекта; клонирует в dest все перечисленные следом  
объекты; совпадающие значения затираются новыми.

Вложенные объекты можно клонировать через `for in` или `_.cloneDeep()` из lodash.
___

**Сборщик мусора** - фоновый auto process JS движка (V8), удаляет недостижимые объекты.

**Недостижимые** - объекты на которые никто не ссылается и они нигде не используются.

Алгоритм сборщика идёт от корня и помечает объекты, на которые идёт ссылка, все не помеченные объекты удаляются.

Оптимизация сборки:
- generation collection - делит объекты на новые/старые
- incremental collection - поэтапно, чтобы избежать одной долгой задержки
- idle-time collection - сборка во время простоя CPU
___

**Метод** - функция которая является свойством объекта.
___
___
## this

`this` вычисляется во время выполнения кода и зависит от контекста вызова.

Если внутри функции используется this, обычно ожидается что функция будет вызываться в контексте объекта.

**this в JS** - свободный, т.е. вычисляется в ходе выполнения. В других языках this фиксированный - указывает на свой объект.

**this в методах объекта** - для доступа к информации внутри этого объекта.

**this в функции** == undefined в Strict mode, в нестрогом window (исторически сложившееся поведение).

**У стрелочных** функций нет своего this, берёт из внешней функции.
___

**Constructor** и оператор `new` позволяют создавать однотипные объекты.
___

**Constructor** - это просто функция названная с большой буквы (по соглашению) и вызывается через `new`.

Технически любую функцию можно вызвать через `new` (кроме стрелок).
___

**Алгоритм при при вызове через new:**

```
function User(name) {
  this = {};  // неявно
  this.name = name;
  return this;  // неявно
}
```
___

Сложный объект можно создать с помощью **анонимной функции constructor:**

```
const user = new function() {  // конструктор одноразовый, т.к. анонимный
  this.name = 'Anna';
  ...
}
```
___

`new.target` - (внутри конструктора) вернёт саму функцию, если вызвана через new, иначе undefined.
___

Если в конструктор не передаются аргументы, то `()` можно не писать.

```
new Date;
```
___

`?.` - опциональная цепочка; вернёт undefined, если часть перед `?` == null/undefined, и прекращает все дальнейшие  
вычисления и вызовы.

```
user.getName?.();  // если getName не существует, вызова не будет

user?.['1'];

delete user?.name;  // удалит если user существует
```

`?.` нельзя использовать в левой части присваивания.
___
___
## Types

Примитив хранит одно значение примитивного типа, а объект хранит множество значений как свойства.

Примитивы имеют свои **объекты-обёртки** (String, Boolean, Number, Symbol).  
При вызове метода у примитива, создаётся такой объект-обёртка, запускается метод, возвращается результат,  
обёртка удаляется.

```
// метод конструктора String
'name'.toUpperCase();  

// конструкторы String, Number, Boolean не стоит вызывать через new
typeof new String('str');  // object
```

`null, undefined` - самые примитивные, не имеют обёрток и методов.
___
___
### Symbol

`Symbol` - уникальный идентификатор.

Symbol и string только могут быть ключами в объекте.

```
// id - имя/описание символа
// два символа с одним и тем же именем не будут равны
const id = Symbol('id');

id.description;  // 'id'
id.toString();  // 'Symbol(id)'
```
___

**Symbol позволяет** создавать скрытые свойства объекта, доступные только из кода где создан символ.
___

Symbol в литерале объекта пишется через `[]`.

```
const id = Symbol('id');
const obj = {
  [id]: 123,
};
```
___

**Symbol не перебирается** в `for in`, `Object.keys()`, но `Object.assign()` копирует символы.
___

**Глобальный реестр символов** - пространство где можно создать многоразовые символы.

`Symbol.for(key)` - получить или создать, если такого нет, символ из реестра.

**Глобальные символы** - доступны везде.

`Symbol.keyFor(Symbol)` - принимает глобальный символ и возвращает его имя или undefined (то же что метод  
`description` для не глобальных символов).

`Reflect.ownKeys(obj)`  
`Object.getOwnPropertySymbols(obj)` - возвращают все свойства, в т.ч. с ключами-символами.  
___
___
### Number

```
const million = 1e6;  // e указывает количество нулей

const ms = 1e-6;  // 0.000001 (6 нулей)

123e-2 == 1.23
```
___

`0x` - шестнадцатеричные числа (`0xff` == 255).

`0o` - восьмеричные числа (`0o377` == 255).

`0b` - двоичные (бинарные) числа (`0b11111111` == 255).
___

`num.toString(base)` - строковое представление числа по указанному основанию; base = 10 по дефолту.

```
const num = 255;

num.toString(16);  // ff

// так не работает
255.toString();  // SyntaxError, потому что первая точка ожидает ввода дробной части

// а так норм
255.0.toString();
255..toString();
(255).toString();
```
___

Округления:
- `Math.floor()` - в меньшую сторону.
- `Math.ceil()` - в большую сторону.
- `Math.round()` - математическое округление.
- `Math.trunc()` - отбросит дробную часть.
- `num.toFixed(n)` - округление до n знаков после запятой; если n не указан, то отбросит всю дробную часть; делает  
  математическое округление; возвращает string.  
- `num.toPrecision(n)` - вернёт строковое представление числа; n - количество знаков всего; округляет математически.

```
Math.floor(1.9);  // 1
Math.ceil(1.1);  // 2
Math.round(1.5);  // 2
Math.trunc(1.99);  // 1

(1.99).toFixed();  // '2' - отбросит дробную часть с математическим округлением
(1.19999).toFixed(2);  // '1.20'
(44).toFixed(2);  // '44.00'

(1.999).toPrecision();  // '1.999'
(1.999).toPrecision(2);  // '2.0'
(44).toPrecision(4);  // '44.00'
```
___

Число в JS хранится в 64-битном формате:
- 52 бита - для цифр
- 11 бит - положение десятичной точки
- 1 бит - для знака
___

**Неточность вычислений в JS** - причина в двоичном представлении десятичного числа.

`IEEE-754` - стандарт формата числа в JS.

Например 0.1 в двоичном представлении будет бесконечной дробью, которая округляется, что и приводит к неточности.

Также происходит округление когда не хватает бит для хранения числа.

```
console.log(9999999999999999);  // 10000000000000000
```
___

В JS есть `0` и `-0`, их отличия игнорируются операторами сравнения.
___

`Infinity` `-Infinity` `NaN` - относятся к типу number.

`isNaN` - проверка на NaN, т.к. NaN не равен ни чему, даже самому себе.

`isFinite()` - вернёт true для любого числа, но false - для NaN, Infinity, -Infinity.

```
NaN === NaN;  // false

Object.is(NaN, NaN);  // true
```
___

`Object.is(value1, value2)` - Метод сравнения как `===`, кроме двух кейсов:

```
Object.is(NaN, NaN);  // true, === вернёт false

Object.is(0, -0);  // false, === вернёт true
```
___

`parseInt(string, [base])`  
`parseFloat(string, [base])` - парсят число (число с запятой) из строки типа `'10px'`; base - опциональное основание.

```
parseInt('12.5px');  // 12 - отбрасывает все после запятой
parseFloat('12.5px');  // 12.5
parseInt('$12');  // NaN
parseInt('0xffgg', 16);  // 255  треш типа gg отбросит
```
___

При работе с дробями, числа в JS теряют точность, нельзя использовать операторы сравнения в лоб.
___
___
### String

`UTF-16` - внутренний формат строк.
___

`for (let char of 'string') {}` - можно перебирать строку.
___

```
'Hey you!'.includes('you');  // true
```
___

`startsWith()`  
`endsWith()` - проверяет начинается/заканчивается ли строка подстрокой, указанной в аргументе.

```
'hi'.startsWith('h');  // true
```
___

**Получение подстроки:**  
- `slice(start, end)` - взять подстроку от start до end (не включая end); можно использовать отрицательные значения.
- `substring(start, end)` - между start и end; отрицательное значение == 0.
- `substr(start, length)` - (old method) length символов начиная от start; start может быть отрицательным.
___

**Сравнение строк:**  
- Строки сравниваются посимвольно в алфавитном порядке.
- Маленькая буква больше заглавной.
- Диакритические знаки (ё) идут не по порядку первыми.
___

`codePointAt(idx)` - вернёт unicode символа на позиции idx.

`String.fromCodePoint()` - вернёт строку созданную из указанной последовательности кодов.

`str.localCompare(str2)` - правильное сравнение строк с учётом языка окружения.

`String.fromCharCode()`  
`charCodeAt()` - то же что методы выше, но устаревшие (не работают с суррогатными парами).

**Суррогатная пара** - редкие символы, записываются двумя 16-битными кодовыми единицами.
___

**Диакритические знаки** - специальные знаки над/под буквами (типа ё).

`s\u0307` - пример unicode диакритического знака.

`str.normalize(form)` - нормализация символов с диакритическими знаками (например для корректного сравнения);  
form - определяет форму нормализации (NFC, NFD, NFKC, NFKD).
___

`str.trim()` - убирает пробелы в начале/конце строки.

`str.repeat(n)` - повторяет строку n раз.
___

`\u2026` - **многоточие** одним символом.
___
___
### Array

**Очередь** - упорядоченная коллекция элементов, поддерживающая 2 вида операций:  
- `push` - добавить элемент в конец
- `shift` - удалить элемент в начале, сдвигая очередь влево.

**Стек** - структура данных, поддерживающая операции:  
- `push` - добавить элемент в конец
- `pop` - удалить последний элемент

**Двусторонняя очередь** - может как стек и очередь; по сути это и есть массив в JS.
___

`push`, `unshift` - добавить элемент (или несколько через запятую) в конец/начало массива.

`pop`, `shift` - удалить последний/первый элемент массива; возвращает сам удалённый элемент.
___

**Массив в JS** - упорядоченная структура данных с числовым индексом; относится к типу object, расширяет его  
специальными свойствами и методами.

Массив копируется по ссылке, т.к. это object.

Массив эффективен только если содержит упорядоченный данные (т.е. индекс по порядку от 0).

Массиву можно присвоить свойство с нечисловым ключом; движок будет работать с таким массивом как с объектом и не  
будут работать специфические методы массива.

```
const arr = [];

arr.name = 'Anna';
```
___

`push, pop` - **быстрые**, `shift, unshift` - **медленные**, т.к. при работе с началом массива, нужно изменять все индексы.
___

`for of` - цикл for с сокращённым синтаксисом для перебора массива.
___

`for in` - также можно использовать для массива, но он медленный и перебирает все свойства, в т.ч. с нечисловым ключом.
___

`length` - содержит не длину, а последний числовой индекс элемента + 1.

```
const arr = [];

arr[100] = 'sto';
arr.length;  // 101
```

`length` можно переназначить, т.е. если length назначить число меньше длины массива, то элемент с конца невозвратно  
удалится.

`arr.length = 0;` - простой способ очистить массив.
___

`new Array(5)` - создаст новый массив с length = 5, с пустыми значениями.
___

Массив можно привести к строке через String:

```
String([1, 2, 3]);  // '1,2,3'
```
___

`slice()` - без аргументов делает **копию массива**.
___

`concat(arg)` - создаёт новый массив, в который копирует данные из переданных массивов + дополнительные аргументы.

```
[1, 2].concat([3, 4]);  // [1, 2, 3, 4]
```
___

`sort()` - без функции сравнения в аргументе сортирует в лексиграфическом порядке (т.е. элементы приводятся к строке  
и сравниваются как строки).

Для функции сравнения достаточно вернуть любое положительное/отрицательное число.

```
[2, 1].sort((a, b) => a - b);
```
___

`reduce` - если нет initial, в качестве него берётся первый элемент, и перебор начинается со второго, НО если массив  
окажется пустым, то будет ошибка (это если нет initial, если есть, то reduce пустого массива вернёт initial).

`reduceRight` - то же что reduce, но перебор справа налево.
___

`Array.isArray()` - проверка является ли массивом; `typeof []` вернёт object, ибо массив в JS не является отдельным типом.
___

`find(fn, thisArg)` - почти у всех методов массива есть второй опциональный параметр - **this**.
___

`arr.some(fn)`  
`arr.every(fn)` - если callback-функция для какого-либо/всех элементов вернёт true, то метод вернёт true, иначе false.
___

`arr.fill(value, start, end)` - заполнит массив одинаковыми элементами от start до end (не включая end);  
заполнит весь массив если без start, end.

```
[1, 2, 3, 4].fill(0, 2, 4);  // [1, 2, 0, 0]
```
___

`arr.copyWithin(target, start, end)` - копирует элементы между start и end и вставляет начиная с индекса target.

```
[1, 2, 3, 4, 5].copyWithin(0, 2, 4);  // [3, 4, 3, 4, 5]
```
___
___
## Iterable objects

**Итерируемые объекты** - реализуют метод `Symbol.iterator`.

`Symbol.iterator` - скрыто есть у любого итерируемого объекта (string, array, map, set);  
содержит метод `next()`.

`next()` - возвращает объект {done: boolean, value: any}.

```
// пример явного вызова итератора
const iterator = 'string'[Symbol.iterator]();

while (true) {
  const res = iterator.next();

  if (res.done) break;

  console.log(res.value);
}
```

**Псевдомассивы** - объекты с цифровыми индексами (свойствами) и есть свойство length.

```
const arrayLike = {
  0: 'hello',        // числовой ключ приводится к строке
  1: 'world',
  length: 2,
};
```
___

`Array.from(arrayLike, [mapFn, thisArg])` - делает массив из итерируемого объекта/псевдомассива;  
mapFn - обрабатывает каждый элемент.
___
___
## Map Set

**Map** -  коллекция ключ-значение, но использует ключи любого типа;  
имеет встроенные методы:  
- `.set(key, value)`
- `.get(key)`
- `.has(key)`
- `.delete(key)`
- `.clear()`
- `.size`

Можно использовать объекты как ключи.
___

`.set()` - возвращает изменённый map, поэтому вызов можно объединить в цепочку.

```
map.set(...)
  .set(...)
  .set(...)
```
___

**Методы перебора:**
- `map.keys()` - возвращает итерируемый объект ключей.
- `map.values()` - возвращает итерируемый объект значений.
- `map.entries()` - возвращает итерируемый объект `[key, value]`.
- `map.forEach()`
___

Для **создания map** используется массив пар ключ-значение.

```
const map = new Map([
  ['1', 'value'],
  [1, 'value'],
  [true, 'value'],
]);
```
___

```
// сделать map из объекта
new Map(Object.entries(obj));

// объект из map
Object.fromEntries(map);
```
___

**Set** - коллекция уникальных значений без ключей (аля массив).

`new Set(arr)` - создаёт set из итерируемого объекта (массива, строки и пр).

**Методы:**
- `set.add(value)` - добавить value (добавит если оно уникально); возвращает изменённый set.
- `set.delete(value)` - удалить; возвращает boolean.
- `set.has(value)` - проверить наличие value; возвращает boolean.
- `set.clear()`
- `set.size`
- `set.values()` - итерируемый объект значений.
- `set.keys()` - то же что `.values()`; для совместимости с map.
- `set.entries()` - вернёт объект `[value, value]`; для совместимости с map.
- `set.forEach((value, value, set) => {})` - два value для совместимости с тем же методом у map.
___

```
const set = new Set([1, 2, 1]);  // [1, 2]

const set2 = new Set('gggfff');  // ['g', 'f']

let set = new Set('hi all hi all'.split(' '));  // ['hi', 'all']
```
___

Set перебирается через `forEach`, `for of`.
___

```
// функция возвращает массив уникальных значений
const uniq = (arr) => Array.from(new Set(arr));
```
___
___
## WeakMap WeakSet

**WeakMap** - подобна Map, но ключи могут быть только объекты.

**WeakSet** - подобна Set, но хранит только объекты.
___

WeakMap/WeakSet удаляет данные как только объект (в качестве ключа в WeakMap) становится недостижимым вне коллекции.  
Т.е. если на объект нет ссылок вне WeakMap/WeakSet, то значение потрётся сборщиком мусора JS.
___

Обе структуры не поддерживают свойства и методы для всего содержимого, т.к. оно неопределённо в разное время.

`keys(), values(), entries(), forEach(), for of, size` - не работают.
___

**Используются** в основном как дополнительные хранилища к основному, типа как кеш.

Иначе:  
Если объект больше не используется в основном коде, то он (и связанные с ним значения) автоматически удалятся из  
Weak структуры.

Map и Set хранят данные постоянно.
___

`keys()`  
`values()`  
`entries()` - методы есть у Map, Set, Array; возвращают итерируемый объект.

`Object.keys()`  
`Object.values()`  
`Object.entries()` - такие же методы для простого объекта; игнорирует Symbols; возвращают массив; сделаны как статические  свойства Object, т.к. в объекте может содержатся свойство keys.

`Object.getOwnPropertySymbols()` - вернёт массив символов.

`Reflect.ownKeys(obj)` - вернёт все ключи с символами.
___

Как использовать **методы массива на объекте:**
1. `Object.entries(obj)`
2. `map/filter/etc`
3. `Object.fromEntries(arr)`

```
Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, value * 2]));
```
___
___
## Destructuring assignment

```
// пример деструктурирующего присваивания
const [name, surname] = 'Anna Karenina'.split(' ');

const [first,, third] = arr;
```
___

**Деструктуризация работает с любым итерируемым объектом**

```
const [a, b, c] = 'abc';

const [one, two, three] = new Set([1, 2, 3]);
```
___

```
// присваивание объекту
let user = {};

[user.name, user,surname] = arr;
```
___

```
// деструктуризация с Object.entries()
for (let [key, value] of Object.entries(obj)) {...}

// то же с Map
for (let [k, v] of userMap) {...}
```
___

**rest параметры** - остаточные параметры при дестракте массива.

```
// rest - массив остатков
const [first, second, ...rest] = arr;
```
___

```
// пустые значения
const [one, two] = [];

one;  // undefined
two;  // undefined
```
___

**Значения по умолчанию**

```
const [one = 1, two = getTwo()] = arr;

// getTwo() выполнится только если нет второго элемента в arr
```
___

**rest параметры для объектов**

```
const {name, ...rest} = obj;

rest;  // {} с остатками
```
___

При **деструктуризации сложных структур** левая сторона должна повторять структуру правой.
___
___
## Date

**timestamp** - целое число миллисекунд с 01.01.1970; даты до 1970 - отрицательное значение; UTC+0.

**UTC** - Coordinated Universal Time; всемирное координированное время.
___

`new Date()` - без аргументов это текущая дата.

`new Date(100)` - вернёт объект Date с преобразованной из 100 мс датой.

`new Date('2022-10-01')` - вернёт объект Date указанной даты (формат даты может быть через тире, точку, запятую, пробел).

`new Date(year, month, day, hours, min, sec, ms)` - создаст объект Date с заданными параметрами; обязательный только  
первые два (тогда остальные будут = 0, day = 1).
___

**Январь - 0** месяц, декабрь - 11.  

**Воскресенье - 0** день, суббота - 6.
___

**Методы:**
- `getFullYear()`
- `getMonth()`
- `gatDate()` - вернёт день (1-31)
- `getHours()`
- `getMinutes()`
- `getSeconds()`
- `getMilliseconds()`
- `gatDay()` - вернёт день недели от 0 (вс) до 6 (сб)

Все эти методы возвращают значение в местном часовом поясе.
___

Чтобы получить значение даты **по UTC** (т.е. 0 часовой пояс), нужно подставить `UTC` после `get`:

- `getUTCFullYear()`
- `getUTCMonth()`
- etc

`getTime()` - для заданной даты возвращает timestamp (мс с 1 января 1970 UTC+0).

`getTimezoneOffset()` - вернёт разницу в минутах между UTC и локальным временем.

```
new Date().getTimezoneOffset();  // -180 для Мск
```
___

`new Date().toLocaleString(locale, options)` - форматирует дату в местном представлении.
___

**Методы установки даты:**
- `setFullYear()`
- `setMonth()`
- и так далее, но вместо get - set

Также для всех set-методов (кроме setTime(ms)) есть UTC вариант - `setUTCFullYear()` и т.д.

```
// текущая дата, но время 00:00:00
new Date().setHours(0, 0, 0, 0);

// текущая дата с нужным офсетом времени
new Date().setSeconds(new Date().getSeconds() + 20);
```
___

**Автоисправление в Date:**

```
new Date(2022, 0, 32);  // 1 feb 2022
```
___

**Приведение к числу:**

```
Number(new Date());  // число в мс, то же что getTime()
```
___

`date.toISOString()` - ISO 8601 формат даты (`YYYY-MM-DDTHH:mm:ss.sssZ`), где `T` - разделитель, `Z` - (опционально)  
часовой пояс в формате `+-hh:mm`, или просто `Z` - будет UTC+0.
___

**Вычисление разности дат:**

```
const start = new Date();

someHardCalcFunction();

const end = new Date();

console.log(end - start);  // оператор минут приведёт Date к числу мс
                           // но лучше использовать performance.now()
```
___

`Date.now()` - вернёт timestamp; тоже что `new Date().getTime()`, но быстрее, т.к. не создаёт объект Date.
___

`Date.parse(string)` - возвращает timestamp из строки формата `YYYY-MM-DDTHH:mm:ss.sssZ`
___

`performance.now()` - часть браузерного API; вернёт мс с начала загрузки страницы; но можно использовать более точного  
вычисления разности между двумя вызовами.

`microtime` - модуль nodeJS для timestamp.
___

**Последнее число месяца:**

```
new Date(2022, 10 + 1, 0).getDate();

// день передаётся в диапазоне 1-31, 0 это последний день предыдущего месяца
// месяц +1 т.к. 0 день вернёт к предыдущему месяцу
```
___
___
## JSON

`JSON.stringify(value, [replacer, space])` - преобразует объект в json-строку (сериализованный объект); т.е. сначала  форматирует в json, затем в строку.

- `replacer` - (optional) может быть:  
  - массив свойств для сериализации
  - function(key, value)

```
// выберет только свойство name
JSON.stringify(obj, ['name']);

// replacer может проверять условия, делать преобразования/вычисления value
// первый элемент в replacer всегда '': obj , т.е. сам переданный объект, это можно использовать для  
// фильтрации циклических зависимостей
JSON.stringify(obj, (key, value) => key === 'name' ? undefined : value);
```

- `space` - (optional) задаёт отступы.

```
JSON.stringify(obj, null, 4);
```

**JSON.stringify игнорирует** специфичные js свойства:
- методы
- символы
- свойства с undefined
- свойства с циклическими свойствами
- NaN преобразует в null
___

`JSON.parse(str, [reviver])` - десериализует json-строку обратно в объект.  
- reviver - (возродитель) функция вызывается для каждой пары ключ-значение

```
// для поля date вернёт объект Date, а не строку
JSON.parse(str, (k, v) => key === 'date' ? new Date(v) : v);
```
___

`toJSON()` - метод есть у некоторых объектов (например Date).

```
new Date().toJSON();  // '2022-11-06T00:00:00.000Z'
```
___
___
## Function

**Рекурсия**

```
function pow(x, n) {  // n - здесь это глубина рекурсии
  return (n === 1) ? x : (x * pow(x, n - 1));
}
```
___

**Глубина рекурсии** ограничена интерпретатором ~10000, дальше бросит ошибку переполнения стека.
___

**Execution context** - контекст выполнения (вызова); это внутренняя структура данных, хранит инфо о запущенной функции.

Каждый вызов функции имеет свой контекст вызова.

Контекст выполнения содержит:
- место функции в коде
- локальные переменные функции
- this и прочую служебную информацию
___

**При рекурсивном вызове** запоминается контекст каждого вызова отдельно. Количество контекстов выполнения зависит от  
глубины рекурсии (количества итераций).
___

При выполнении вложенных функций, JS хранит контексты их вызова в **стеке вызова** (call stack).
___

Любая рекурсия может быть переделана в цикл. Цикл как правило эффективнее, т.к. использует 1 контекст.  
Но код с рекурсией более краток и не использует мутацию.
___

**Связанный список** - структура данных, позволяет быстро удалить/вставить элемент (быстрее массива).

```
{
  value: 1,
  next: {     //  кроме next, может ещё иметь prev, tail
    value: 2,
    next: {
      ...etc
    }
  }
}
```
___
___
### Lexical environment

**Лексическое окружение** - скрытый внутренний объект js; есть у каждой функции, блока кода (даже если просто обернуть  
в `{}`), скрипта.

Состоит из двух частей:
1. **Environment Record** - объект, хранит все локальные переменные как свойства.
2. **outer** - ссылка на внешнее лексическое окружение (у глобального = null).

**Переменная** - это по сути свойство объекта Environment Record.

**Function Declaration** попадают в глобальное лексическое окружение первыми (при первом парсинге скрипта), до переменных  
и до вызова самой функции.

При первом запуске функции создаётся **отдельное лексическое окружение** для локальных переменных и аргументов функции.

Если код внутри функции обращается к переменной, то сначала идёт её поиск в локальном окружении, и если не находит, то  
ищет в текущем внешнем.

Функция получает текущее на момент выполнение значение внешних переменных.

`Environment` - скрытое свойство, есть у каждой функции; содержит ссылку на лексическое окружение, где функция была создана.

Объект лексического окружения стирается только тогда, когда ни одно свойство Environment не будет ссылаться на него.
___
___
### Замыкание

**Замыкание** - функция которая запоминает внешние переменные, которые использует, и имеет к ним доступ.

В JS все функции изначально являются замыканиями, т.к. имеют свойство Environment, содержащее ссылку на окружение  
где была создана функция.
___

Благодаря объекту LexicalEnvironment, конкретно ссылке на внешнее окружение, можно получить **доступ** к любым внешним  
переменным и функциям. Но обратно не работает: переменные внутри любого {} блока не доступны для внешнего окружения.
___

Для циклов `for`, `while` создаётся отдельное лексическое окружение для каждой итерации, с сохранением текущей  
переменной счётчика (если она объявлена как `for (let i = ...`).
___

В браузере все скрипты (из разных файлов) имеют одну общую область видимости, кроме скрипта `type="module"`.
___

**IIFE** (immediately invoked function expression) варианты объявления:
- `(function(){...})();`
- `(function(){...}());`
- `!function(){...}();`
- `+function(){...}();`

Трюки чтобы показать движку что это function expression, а не function declaration. Иначе будет ошибка объявления  
function declaration без имени.
___

Лексическое окружение функции стирается после её выполнения, если функция не возвращает callback.
___

Движок удаляет неиспользуемы переменные из лексического окружения, если на них нет ссылок.

Также линтер выделяет варнингом неиспользуемые переменные, т.к. они будут потёрты сборщиком мусора.
___

**Пример работы сборщика V8:**

```
const value = 'val1';

function f() {
  const value = 'val2';

  return () => {
    debugger;     // если здесь выполнить console.log(value), то вернёт val1, т.к. на value внутри f
  };              // нет ссылок, то сборщик стёр эту переменную
}
```
___

Если `var` переменная внутри функции, то она ограничена лексическим окружением функции.  
Вне функции var станет глобальной переменной (например в `if`).

Все объявления var всплывают (hoisting) не верх скрипта/функции.

Переменный и функции, объявленные через `var`, становятся свойствами глобального объекта (const/let - нет).
___

**Глобальный объект** - (`window`, `global` в nodeJS) предоставляет переменные и методы; доступны везде в коде.

`globalThis` - ссылается на глобальный объект.
___

Можно **записывать глобальные переменные**, но не стоит:

```
window.user = {name: 'Anna'};

user;  // Anna - в любом месте кода
```
___

Пример **проверки поддержки** браузером:

```
if (!window.Promise) alert('Browser is old!');
```
___

В JS функция имеет тип object; у каждой функции есть свойства `name` - имя функции, `length` - количество аргументов.

```
function foo(a, b) {...}

foo.name;  // 'foo'
foo.length  // 2
```

 Можно использовать для **Ad-hoc полиморфизма** - обработка аргументов функции по разному, в зависимости от типа или  количества аргументов (через length свойство функции).
___

Така как функция это объект, то можно **добавить свои свойства**:

```
function foo() {
  const bar = 10;

  foo.bar = 11;

  return bar;
}

foo();  // 10
foo.bar;  // 11

// у foo() и foo.bar разный scope
```

```
function makeCounter() {
  function counter() {
    return counter.count++;  // создали свойство count у объекта counter, с инкрементом
  }

  counter.count = 0;  // задали начальное значение count; эьл не равно объявлению переменной

  return counter;
}
```

Отличие такого способа от создания внутренней переменной в том, что к такому свойству можно обратиться извне функции.
___

**NFE** - Named Function Expression; позволяет делать рекурсивный вызов FE.

```
const sayHi = function foo(name) {
  if (name) {
    console.log(`Hello ${name}`);
  } else {
    foo('Guest');
  }
}
```
___

`new Function(arg1, ...argN, functionBody)` - редкий синтаксис объявления функции; функция создаётся из строки,  
переданной в рантайме. Используется редко, например если тело функции приходит с сервера.

Функция созданная через `new Function` содержит в свойстве `Environment` ссылку на глобальное лексическое окружение  
(а не то в котором она была создана).

То есть такая функция не является замыканием.

```
const sum = new Function('a', 'b', 'return a + b');  // аргументы опциональны, можно передать 'a, b'

sum(1, 2);  // 3
```
___
___

### Decorators

**Декоратор** - функция которая принимает другую функцию и изменяет её поведение (например для кеширования,  
логирования, ...).

```
function cachingDecorator(fn) {
  const cache = new Map();

  return function(x) {
    if (cache.has(x)) return cache.get(x);

    const result = fn(x);

    cache.set(x, result);

    return result;
  }
}
```
___

**Call forwarding** - перенаправление вызова; передача всех аргументов вместе с контекстом в другую функцию.

`call(context, ...args)` - встроенный метод Function, позволяет вызывать функцию, явно устанавливая `this`.

`apply(this, args)` - то же, но args - псевдомассив, а не список аргументов; лучше оптимизирован, быстрее `call`.
___

**Заимствование метода:**

```
function hash() {
  return [].join.call(arguments);  // берём метод массива для псевдомассива arguments
}
```

Технически `join` принимает `this`, который мы передали в `call` и объединяет каждый элемент `arguments`.

`join(glue)` - glue по дефолту `,`
___

**Полезные декораторы:**
- spy/log
- debounce
- delay
- throttle

**Spy** - возвращает обёртку, которая хранит все вызовы с аргументами.

```
function spy(fn) {
  function wrapper(...args) {
    wrapper.calls.push(args);

    return fn.apply(this, args);
  }

  wrapper.calls = [];

  return wrapper;
}
```

**Debounce** - не позволяет спамить вызовы во время установленной задержки (например в input - делает вызов когда  
юзер прекратит ввод + delay).

```
function debounce(fn, ms) {
  let isRunning = false;

  return function() {
    if (!isRunning) {
      fn.apply(this, arguments);  // apply позволяет использовать декоратор и с методами объектов
      isRunning = true;           // obj.foo = debounce(obj.foo)
      setTimeout(() => isRunning = false, ms);
    }
  };
}
```

**Delay** - задерживает вызов на n мс.

```
function delay(fn, ms) {
  return setTimeout(() => fn.apply(this, arguments), ms);  // стрелка не имеет this и argument 
                                                           // и берёт их из функции-обёртки
}
```

**Throttle** - (тормозящий) как debounce, но вызывается последний вызов после задержки.

```
function throttle(fn, ms) {
  let isRunning = false;
  let lastCall;

  return function wrapper() {
    lastCall = arguments;

    if (!isRunning) {
      fn.apply(this, arguments);
      isRunning = true;
      setTimeout(() => {
        isRunning = false;
        lastCall && wrapper.apply(this, lastCall);
        lastCall = null;
      }, ms);
    }
  };
}
```
___

**Потеря контекста** - если использовать метод объекта отдельно от объекта, то this теряется.
___

`this` в `setTimeout/setInterval == window`.

В nodeJS this будет объектом таймера.
___

`bind()` - встроенный метод функций, позволяет зафиксировать контекст; возвращает функцию с привязанным this, но не  
вызывает её как call/apply.

```
let user = {
  name: 'Anna',
  sayHi(phrase) {
    alert(`${phrase}, ${this.name}`);
  }
};

const say = user.sayHi.bind(user);

say('Hi');  // 'Hi, Anna'
```
___

`_.bindAll(obj)` - функция lodash для массовой привязки контекста.
___

**Частично применённая функция** - функция с фиксированными аргументами.

```
const mul = (a, b) => a *b;
const double = mul.bind(null, 2);  // this - обязательный аргумент, поэтому передаём null

double(4);  // 8
```
___

**Фиксация части аргументов:**

```
function partial(fn, ...argsBound) {
  return function(...args) {
    return fn.call(this, ...argsBound, ...args);
  };
}
```
___
___

### Arrow function

У стрелок нет `this`, если обратиться к this внутри стрелочной функции, то значение берётся из внешнего лексического  
окружения (как обычная переменная), т.е. берёт контекст там где её используют.
___

Отсутствие своего this и arguments полезно при использовании функции как **callback**, чтобы не выходить из текущего  контекста. По сути стрелочная функция для этого и создана.

```
const group = {
  title: 'Our group',
  students: ['Anna', 'John'],
  showList() {
    this.students.forEach(student => `S{this.title}: ${student}`)  // у стрелки нет this, поэтому значение this берётся
  }                                                                // из функции showList, где this == group
};
```
___

Так как у стрелок нет this, они не могут использоваться в `constructor`, и не может быть вызвана через `new`.
___

У стрелок нет псевдомассива `arguments`, что тоже удобно при использовании функции как callback.

```
function deferDecorator(fn, ms) {
  return function() {
    setTimeout(() => fn.apply(this, arguments), ms);  // т.к. у стрелок нет this и arguments, то эти значения берутся из
  };                                                  // ближайшего лексического окружения
}
```
___

Также у стрелок нет своего `super`, берёт из внешней функции.

```
class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 100);
  }
}
```
___
___

## Timers

`setTimeout()`, `setInterval()` - устанавливает задержку, по истечении которой выполняется callback.  
- первый аргумент - функция или строка с функцией
- второй аргумент - delay
- третий и последующие - аргументы которые передаются в callback

Возвращает id таймера для использования в `clearTimeout/clearInterval`.
___

**Рекурсивный setTimeout** обеспечивает более предсказуемую задержку, чем `setInterval`.

`setInterval` считает задержку вместе со временем выполнения callback, рекурсивный `setTimeout` устанавливает задержку  
после выполнения callback.

```
setTimeout(function run() {
  func();  // основная выполняемая функция

  setTimeout(run, 100);
}, 100);
```
___

Callback из `setTimeout/setInterval` не удаляются сборщиком мусора, т.к. в планировщике движка браузера сохраняется  
ссылка ни него.

Также, каждый такой callback имеет `Environment`, ссылающийся на внешнее лексическое окружение, в котором есть ссылки  
на внешние переменные, следовательно сборщик мусора не потрёт их.

Короче, любой вызов таймера может сильно нагрузить память, поэтому `clearTimeout/clearInterval` - обязательно!
___

`setTimeout(fn)` - (delay = 0 по дефолту) выполнит fn сразу после основного кода; способ прокинуть функцию в macroTask  
очередь.

**Но** интервал = 0 только первые 5 вызовов, дальше задержка ~4 мс (прописано в стандарте HTML5).  
Реальная задержка зависит зависит от многого:  
- загрузка cpu
- вкладка в фоновом режиме
- работа ПК от аккумулятора
- и пр.
___
___

## Extended object properties

**Дескрипторы свойств** - помимо value, свойства объекта имеют 3 скрытых флага:
- `writable` - можно ли переписать свойство
- `enumerable` - можно ли перебирать в циклах
- `configurable` - можно ли удалить свойство и изменять эти флаги

Все эти атрибуты есть у каждого свойства объекта скрыто.

При обычном создании свойства, все эти атрибуты = true.
___

`Object.getOwnPropertyDescriptor(obj, propName)` - метод возвращает **дескриптор** - объект со всеми скрытыми флагами,  
для указанного свойства.

`Object.getOwnPropertyDescriptors(obj)` - вернёт объект с объектами-дескрипторами для каждого свойства.
___

`Object.defineProperty(obj, propName, descriptor)` - метод для создания свойства с объектом-дескриптором; если в  
дескрипторе описать только value, то все флаги будут false.

Если свойство существует, то `defineProperty` обновит флаги. Все не описанные в дескрипторе флаги станут false.

```
// определение свойства только для чтения
const user = {name: 'Anna'};

Object.defineProperty(user, 'name', {
  writable: false
});

user.name = 'John';  // error в Strict mode, в нестрогом просто игнорируется
```
___

`Object.defineProperties(obj, props)` - то же что `defineProperty`, но создаёт сразу несколько свойств с дескрипторами.

```
Object.defineProperties(user, {
  name: {
    value: 'Anna',
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 40  // все неуказанные флаги будут false
  }
});
```
___

При установке `configurable: false` мы больше не сможем изменить это поле через defineProperty.
___

**Копирование объекта** со всеми свойствами (в т.ч. символы) и дескрипторами:

```
const mathClone = Object.defineProperties(
  {},
  Object.getOwnPropertyDescriptors(Math)  // получим Math со всеми свойствами
);

// не работает
Object.assign({}, Math);  // {}
```
___

`Object.assign(target, source)` - копирует все перечислимые собственный свойства объекта; в source может принимать  
несколько объектов через запятую.

`object.create(proto, props)` - вернёт новый объект, созданный с указанным прототипом.
___

**Способы заморозки объекта:**
- `Object.preventExtensions(obj)` - запретить добавление новых свойств,но можно удалить/изменить имеющиеся.
- `Object.seal(obj)` - запретить добавлять/удалять свойства, можно только изменять (`configurable: false`).
- `object.freeze(obj)` - запретить добавлять/удалять/изменять свойства, можно только перебирать в цикле (`writable: false, configurable: false`).

Всё это глобальные способы, дескрипторы работают только для конкретных свойств.

**Способы проверки на заморозку:**
- `Object.isExtensible(obj)` - вернёт false если добавление свойств запрещено.
- `object.isSeal(obj)` - вернёт true если для всех свойств установлено `configurable: false`.
- `Object.isFrozen(obj)` - вернёт true если для всех свойств установлено `configurable: false, writable: false`.
___

### Getter/setter

У объектов **2 типа свойств:**
- data properties (обычные свойства)
- accessor properties

**Accessor** - по сути функции, которые используются для присвоения/получения значения, но в клиентском (внешнем) коде  
они выглядят как обычные свойства.

```
const user = {
  name: 'John',
  surname: 'Smith',
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  set fullName(value) {                            // set принимает 1 аргумент
    [this.name, this.surname] = value.split(' ');  // деструктирующее присваивание
  }
};
```

**Дескрипторы свойств-аксессоров:**
- `get`
- `set`
- `enumerable`
- `configurable`

Дескрипторы аксессоров не имеют `value`.
___
___

## Наследование, prototype

**Прототипное наследование** - тип наследования в JS; суть: если в свойствах объекта нет искомого свойства, то js ищет  
его в объекте родителе через прототип.
___

`__proto__` - геттер/сеттер для prototype; поддерживается браузерами и nodeJS; есть у всех типов, кроме null и undefined.

`Object.getPrototypeOf()`  
`Object.setPrototypeOf()` - более свежий аналог `__proto__` (ES6).
___

Свойство, доступное через proto, нельзя изменить/удалить, если это не сеттер.

`this` - в наследуемом методе всегда будет объект перед точкой.

```
const animal = {
  eats: true,
  walk() {
    alert('walk');
  }
};

const rabbit = {
  jumps: true,
  __proto__: animal  // цепочка прототипов может быть длинной
};

rabbit.walk();  // 'walk' если бы использовался this, то был бы равен rabbit
rabbit.hasOwnProperty('walk');  // false т.к. покажет только собственные свойства, не наследованные
```
___

**Ограничения:**
- циклические ссылки нельзя
- proto может быть объект или null
- prototype может быть только 1
___

`obj.hasOwnProperty(key)` - проверяет собственное ли свойство.

```
for (let key in obj) {
  if (obj.hasOwnProperty(key)) alert(key);  // for in перебирает унаследованные свойства, Object.keys  и пр. - нет
}
```
___

Поиск свойства/метода через цепочку прототипов практически не аффектит производительность.
___

`prototype` - свойство есть у всех функций, используется только при вызове через `new`, присваивается как прототип  
нового объекта.

```
const animal = {eats: true};

function Rabbit(name) {  // функция-конструктор, типа класса
  this.name = name;
}

// 2 варианта присвоения прототипу
// второй вариант лучше, т.к. не затирает prototype.constructor
Rabbit.prototype = animal;
Rabbit.prototype.getName = function() {
  return this.name;
};

const rabbit = new Rabbit('Bunny');
```
___

**По дефолту** `func.prototype` содержит объект со свойством constructor - содержит ссылку на функцию-конструктор.
___

`[[Prototype]]` - скрытое свойство; бывает либо null, либо объект прототип.

`[[...]]` - скрытое внутреннее свойство.
___

**Пример использования конструктора:**
```
const arr = new Array;

arr.constructor === Array;  // true

// для литералов
[].__proto__.constructor === Array;  // true

function Animal(name) {
  this.name = name;
}

const dog = new Animal('Bob');

// если неизвестен не доступен конструктор (например внешняя библиотека)
const dog2 = new dog.constructor('Bim');
```
___

**Восстановление конструктора:**

JS не гарантирует правильное значение конструктора.

```
// Animal из примера выше
Animal.prototype = {jump: true};
dog.constructor === Animal;  // false, т.к. prototype, содержащий конструктор, переписан

// правильный вариант:
Animal.prototype.jumps = true;

// либо восстановить конструктор
Animal.prototype = {
  jump: true,
  constructor: Animal
};
```
___

`Object, String, Array, Function, etc` - встроенные объекты, которые хранят специальные методы в prototype.

`Object` - находится наверху иерархии в JS, от него наследуют все другие встроенные объекты; `Object.__proto__` равно null.
___

Можно **изменять/добавлять свои методы строенных объектов**, но это плохая практика, т.к. свойство prototype глобальное.

```
String.prototype.show = function() {
  alert(this);
};
```

**Создание полифилов** - единственно когда приемлемо изменять встроенный прототип.

```
String.prototype.repeat = function(n) {
  return new Array(n + 1).join(this);  // сама строка будет glue
};

'bla'.repeat(2);  // 'blabla'
```
___

Пример **заимствования у prototype:**

```
const obj = {
  0: '0',
  1: '1',
  length: 2
};

obj.join = Array.prototype.join;  // добавит метод массива к псевдомассиву (не всегда работает)
```
___

Изменение prototype через `Object.setPrototypeOf` или `__proto__` ломает внутреннюю оптимизацию движка, замедляет работу  
кода.
___

`Object.create(prototype, [descriptors])` - создаёт пустой объект с указанным прототипом.

```
const animal = {eats: true};
const rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});

rabbit;  // {jumps: true}, но в prototype есть наследованное свойство eats: true
```
___

Пример **клонирования объекта** (поверхностное клонирование свойств):

```
const clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```
___

Пример создания **простейшего объекта** (чистый словарный объект); без прототипа и встроенных методов, но есть статичные  
метода Object:

```
const obj = Object.create(null);
```
___

Ещё методы для объекта:
- `Object.keys(obj)` - вернёт массив ключей
- `Object.values(obj)` - вернёт массив значений
- `Object.entries(obj)` - вернёт массив пар ключ-значение
- `Object.getOwnPropertySymbols(obj)` - вернёт массив собственных символьных ключей
- `Object.getOwnPropertyNames(obj)` - вернёт массив собственных строковых ключей
- `Reflect.ownKeys(obj)` - массив ключей
- `obj.hasOwnProperty(key)` - проверяет есть ли key среди собственных свойств
- `for in` - перебирает все, в т.ч. наследованные свойства объекта
___
___

## Class

При вызове `new MyClass` вызывается метод constructor для инициализации нового объекта.
___

**Class в JS** - разновидность функции.
___

**Что делает class:**
1. создаёт функцию с именем класса, берётся из конструктора класса
2. сохраняет методы класса в prototype
___

**Отличия Class от Function:**
- конструктор класса нельзя вызвать без `new`
- строковое представление класса начинается со слова Class
- методы класса не перечисляются в `for in` (`enumerable: false`)
- класс внутри использует `use strict` по дефолту

Вывод: Class не просто синтаксический сахар над Function.
___

**Class Expression** - как и функции, класс можно определить внутри выражения, передавать, возвращать.

```
const User = class {
  sayHi() {}
};

function makeClass(fn) {
  return class {
    sayHi: fn
  };
}
```
___

Класс может содержать get/set и вычисляемые свойства (`[a + b]: true`).
___

**Синтаксис класса:**

```
class MyClass {
  prop = 'value'  // свойство

  constructor() {}  // конструктор

  method() {}  // метод

  get some() {}  // геттеры/сеттеры
  set some() {}

  ['say' + 'hi']: 'value'  // вычисляемые свойства
}
```
___

`extends` - ключевое слово для наследования класса; работает через prototype, т.е. записывает в prototype дочернего  
класса prototype родителя.
___

**Переопределение методов** - если в дочернем классе создать метод с таким же именем как у родителя, то объект дочернего  
класса будет использовать ближайший т.е. дочерний метод.
___

`super` - вызывает родительский конструктор/метод.

`super.method()` - вызвать родительский метод.

`super()` - вызвать родительский конструктор; работает внутри дочернего конструктора.

```
class Rabbit extends Animal {
  stop() {  // частично переопределили метод родителя, дополнили
    super.stop();
    alert('Stopped');
  }
}
```
___

**Переопределение конструктора:**

Если у дочернего класса нет своего конструктора, то автоматически неявно создаётся такой:

```
class B extends A {
  constructor(...args) {
    super(...args);
  }
}
```

```
// пример переопределения
class B extends A {
  constructor(a, b) {
    super(a);  // в дочернем конструкторе super должен вызываться до присвоения this, иначе ошибка
    this.b = b;
  }
}
```

При вызове обычного конструктора происходит неявное присвоение this пустого объекта. В дочернем конструкторе этого  
не происходит, ожидается вызов родительского конструктора (super) с присвоением `this = {}`.
___

`[[HomeObject]]` - скрытое свойство; присваивается функции объявленной как метод; равна самому объекту.

`super` использует HomeObject для доступа к prototype родителя и его методам.

С помощью HomeObject методы запоминают свои объекты.

`[[HomeObject]]` есть только у методов класса/объекта, объявленного так:

```
method() {}  // синтаксис метода объекта

// но не так
method: function() {}  // синтаксис свойства-функции; при таком объявлении super не работает
```
___

`static` - свойства/методы которые принадлежат самому классу, а не его экземплярам; статические методы присваиваются  
самой функции-классу, а не prototype.

`static isTrue: true;` внутри класса, это то же что `class.isTrue = true;`

static свойства/методы наследуются (т.к. extends наследует и сам класс и его prototype).

static свойства/методы используются создания общей функциональности. В статичные свойства выносят общие для класса  
константы, что экономит память.
___

`#prop` - приватное свойство; доступно только внутри класса, не наследуется, не доступно через this.
___

**Инкапсуляция** - отделение внутреннего (приватного, скрытого) интерфейса от внешнего (публичного).
___

`_prop` - защищённое свойство (именование по соглашению); доступно из класса и иго наследников.
___

**Расширение встроенного класса:**

```
class SuperArray extends Array {  // extends, для встроенных классов, не наследует static методы
  isEmpty() {
    return this.length === 0;
  }
}

const arr = new SuperArray(1, 2, 3).map(item => item + 1);  // встроенный методы возвращают новый массив,
                                                            // унаследованный от SuperArray
```

Оригинальный конструктор Array можно вернуть через специальный статический геттер `Symbol.species`

```
// в дочернем классе
static get [Symbol.species]() {
  return Array;
}
```
___

`instanceof` - оператор, определяет принадлежность к классу; находит ближайшее совпадение по цепочке прототипов, иначе false.

```
[] instanceof Array;  // true

// то же
[].__proto__ === Array.prototype;  // true
```

`isPrototypeOf()` - то же что instanceof; вызывается у prototype.

```
Array.prototype.isPrototypeOf([]);  // true
```

**instanceOf работает так:**
1. проверяет есть ли статичный метод `Symbol.hasInstance`, если есть, то вызывает его, если нету то шаг 2.
2. проверяет на равенство по цепочке прототипов (не учитывая конструктор).

`Symbol.hasInstance` - даёт возможность настроить instanceof.

```
class Animal {
  static [Symbol.hasInstance](obj) {
    if (obj.canEat) return true;
  }
}

const obj = {canEat: true};
obj instanceof Animal;  // true, хотя obj не наследует от Animal
```
___

**toString() для определения типа:**

```
Object.prototype.toString.call(null);  // '[object Null]'

Object.prototype.toString.call();  // '[object Undefined]'
```

Пример более правильной реализации `typeof`:

```
const typeof = (obj) => Object
  .prototype
  .toString
  .call(obj
  ).replace(/[object\w+]/g, '');

typeof(null);  // 'Null'
```

`Symbol.toStringTag` - свойство которое и содержит тип, который выводит toString; можно установить вручную.

```
const a = {
  [Symbol.toStringTag]: 'A'
};

{}.toString.call(a);  // '[object A]'
```
___

**Mixin** - (примесь) это класс который содержит методы для использования в других классах, но без наследования.

Полезно, т.к. класс в JS может наследовать только от одного класса (т.е. имеет только один `[[Prototype]]`).
Т.е. можно создать объект с полезными методами, его добавить в prototype класса, при этом класс может наследовать.  
Типа реализация множественного наследования в JS.

```
const mixin = {
  foo() {}
};

class User {
  constructor(name) {
    this.name = name;
  }
}

Object.assign(User.prototype, mixin);

new User('Anna').foo();
```

Миксин также может наследовать от других миксинов через свойство `__proto__`.

```
const mixin1 = {
  a() {}
};

const mixin2 = {
  b() {
    super.a();
  },
  __proto__: mixin1  // либо через Object.create
};
```
___
___

## Try catch

**Алгоритм:** выполняется блок try, если нет ошибок блок catch игнорируется; если ошибка выполнения в try, то выполнение  
прерывается и управление передаётся в catch.
___

`try catch` **не ловит** синтаксические ошибки, т.к. это ошибки парсинга, а не выполнения кода.
___

`Exception` - (исключение) ошибка выполнения кода.
___

`try catch` **работает синхронно**, если exception будет внутри асинхронного кода, то catch не сработает.
___

`err` в `catch(err) {}`, - объект ошибки, генерируется JS; если не нужны детали можно просто `catch {}`.  
Содержит:
- name
- message
- stack - стек вызовов, которые привели к ошибке 
___

`finally` - блок после catch; выполняется в любом случае.

```
try {
  ...
} catch {
  ...
} finally {
  alert('done');  // выполнится при ошибке и без, даже если в try будет return
}
```
___

`try finally` - если в try будет выброшено исключение, то finally всё равно отработает.

```
try {
  console.log('try starts');
  badCode();  // не существующая функция, выбросит исключение
  console.log('try ends');
} finally {
  console.log('finally');  // всё равно выполнится
}
```
___

**Глобальный catch** - `window.onerror` функция, вызовется при необработанной ошибке или падении всего скрипта;  
аргументы:
- message
- url - адрес скрипта с ошибкой
- line - строка ошибки
- col - колонка ошибки
- error - объект ошибки

```
window.onerror = (message, url, line, col, error) => {
  console.log('error');
};
```

`window.onerror` можно использовать для логирования - отправлять сообщение об ошибке на сервис логирования.
___

`throw` - оператор, генерирует ошибку; может работать с любым значением, но обычно это объект со свойствами name, message.

```
throw 'some error';  // Uncaught some error
```

Обычно throw использует **конструкторы стандартных ошибок**:
- SyntaxError
- ReferenceError
- TypeError
- etc

```
const error = new Error(message);

// или
throw new SyntaxError({
  name: 'Syntax error',
  message: 'Something went wrong!'
});
```
___

**Проброс исключения** - catch обычно обрабатывает известные ему ошибки, неизвестные лучше пробрасывать дальше.

```
catch(e) {
  if (e.name === 'SyntaxError') {  // лучше (e instanceof SyntaxError)
    alert(e);
  } else {
    throw e;  // проброс не распознанной ошибки наружу
  }
}
```
___

**Расширение стандартных ошибок:**

```
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';  // лучше this.name = this.constructor.name
  }
}

throw new ValidationError('yopta!');
```
___

**Обёртывание исключений** - оборачивание нативных исключений (через `extends Error`) в классе, для расширения функционала.
___
___

## Promise

```
const promise = new Promise(executor);
```

**Как работает:**
- executor функция запускается когда создаётся промис
- когда executor получает результат, он вызывает один из коллбеков:
  - resolve(value) - если вызов executor успешен; передаёт в resolve результат выполнения executor (т.е. value)
  - reject(error) - если executor выполнится с ошибкой; error - объект ошибки

**Ещё раз:**

executor  выполняет запрос, затем вызывает resolve/reject чтобы изменить состояние объекта promise.
___

`Promise` - специальный объект; связывает в себе создающий и потребляющий код.
___

`new Promise` возвращает объект с двумя свойствами:
- `[[PromiseState]]` - может быть:
  - `pending` - initial
  - `fulfilled`
  - `rejected`
- `[[PromiseResult]]` - бывает:
  - `undefined` - initial
  - `value` - результат выполнения executor
  - `error` - объект ошибки
___

Объект promise может быть в одном из **двух состояний**:  

(1)
```
{
  state: 'fulfilled',
  result: value
}
```

(2)
```
{
  state: 'rejected',
  result: error
}
```

Промежуточное состояние:
```
{
  state: 'pending',
  result: undefined
}
```
___

`resolve/reject` - вызывается 1 раз, остальные вызовы игнорируются; принимают 0/1 параметр, остальные игнорируются.

Для resolve обычно используется объект Error или унаследованные от него.
___

`then, catch, finally` - функции потребители, подписываются на объект promise; возвращают promise.
___

`.then(onFulfilled, onRejected)` - принимает два коллбека:  
- `onFulfilled()` - сработает при успешном выполнении промиса
- `onRejected()` - при ошибке

```
promise.then(
  (data) => alert(data),  // если для обработки ошибок есть блок catch, то в then передать 1 callback
  (err) => alert(err)  // если нужно обрабатывать только ошибку, то .then(null, (err) => {})
);
```

**Лучше** выстраивать цепочку `then().catch()`, т.к. если внутри обработчика then произойдёт ошибка, то второй callback  
не отловит её, а в цепочке then.catch отлови catch.
___

`.catch(onRejected)` - обработчик ошибок (то же что `.then(null, cb)`); перехватит не только reject, но также SyntaxError  
 и подобные, также ошибки выброшенные `throw`.
___

`.finally()` - выполнится в любом случае (как `finally` в `try catch`); не имеет аргументов; пробрасывает результат/ошибку  
дальше по цепочке; не знает как разрезолвился промиси не имеет доступа к результату/ошибке.

Используется например для остановки loader.

Почти то же что `.then(fn, fn)` - `fn` выполнится при любом состоянии промиса.

```
new Promise((resolve, reject) => {
  setTimeout(() => resolve('Done'), 500);
}).finally(() => alert('Finally'))
  .then((res) => alert(res));
```
___

Пример обработки promise **без catch, finally:**

```
new Promise(...)
  .then((res) => alert(res))
  .then(null, (err) => alert(err))  // как catch
  .then((data) => alert(data), (data) => alert(data));  // почти как finally
```
___

**Цепочка промисов** - последовательный вызов `.then`.

Это возможно т.к. then возвращает promise, на котором можно опять вызвать then (catch, finally также возвращают promise).

```
// then возвращает:
{
  PromiseState: 'fulfilled',
  PromiseResult: 123  // то что попадает внутрь коллбека в then
}
```
___

Функция-обработчик внутри then может вернуть новый промис:

```
promise.then((v) => new Promise((res) => res(v * 2)));
```
___

**thenable** - объект который реализует метод then.

```
class Thenable {
  then(resolve, reject) {...}
}

new Promise(resolve => resolve(1))
  .then((res) => new Thenable(res))
  .then(alert);
```
___

**catch в конце цепочки** then перехватит любые ошибки в обработчиках (не только reject, но и SyntaxError, etc).
___

Если catch обработал ошибку, то следующий then нормально отработает.

```
promise.catch().then();
```
___

`unhandledrejection` - событие которое генерирует браузер для необработанных ошибок в promise.

event объект события содержит свойства:
- promise - сам промис в котором ошибка
- reason - объект ошибки

```
window.addEventListener('unhandledrejection', (event) => {
  console.log(event.promise, event.reason);
});

new Promise(() => {
  throw Error;
});
```
___

### Статические методы Promise

`Promise.all([...promises])` - вернёт промис, который завершится когда завершатся все переданные (обычно в массиве) промисы;  
если хоть один из переданных промисов завершится с ошибкой, то результирующий промис завершится с ошибкой, игнорируя  
успешные промисы; выполняет промисы параллельно.

Возвращает массив результатов переданных промисов, сохраняя порядок.

Если в массиве промисов передан не промис (например примитив), то он передаётся в массив результатов как есть.

```
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 100)),
  new Promise(resolve => setTimeout(() => resolve(2), 0)),
  10
]).then(console.log);  // [1, 2, 10]
```
___

`Promise.allSettled()`- вернёт промис, который ждёт завершения всех переданных промисов, и тех что с ошибкой.

Возвращает массив объектов вида:

```
[
  {status: 'fulfilled', value: 123},
  {status: 'rejected', reason: err}
]
```
___

`Promise.race` - как `Promise.all`, выполняет промисы параллельно, но возвращает первый выполненный промис с результатом  
или ошибкой.
___

`Promise.resolve`  
`Promise.reject` - создаёт зарезолвленный или с ошибкой промис; может использоваться когда нужно чтобы функция возвращала  
значение типа Promise.
___

**Промисификация** - преобразование функции так, чтобы она возвращала промис (для callback based функций)

Годится для функций, вызывают callback 1 раз, остальные вызовы будут игнорироваться.
___

Обработчики промисов (then, catch, finally) являются **асинхронными** и попадают в отдельную очередь микрозадач  
(microtask queue - работает по FIFO) в браузере (выполняются сразу после основного кода, всем батчём).
___

### async await

`async` - функция которая всегда возвращает промис; значения других типов оборачиваются в успешно разрешившийся промис.

```
const fn = async () => 1;

fn().then(alert);  // 1
```

`await` - ключевое слово; говорит интерпретатору ждать пока промис не выполнится; по сути синтаксический сахар  
над `.then`; можно использовать только внутри async функций.
___

Ожидание промиса не блокирует движок (т.к. выполняется в отдельной очереди), который может заниматься другими задачами.
___

await **работает с thenable** объектами:

```
async function fn() {
  const res = await new Thenable(1);  // класс реализующий метод then
}
```
___

Пример **async метода** класса:

```
class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}

new Waiter().wait().then(alert);  // then возможен, т.к. async await возвращает Promise
```
___

Для **обработки ошибок** в `async await` используется `try catch`.

await, завершившийся ошибкой, выбрасывает исключение.

Вместо `try catch` можно использовать `.catch` обработчик, т.к. async функция вернёт промис в состоянии rejected, при ошибке.

```
async function fn() {
  const res = await fetch('');
}

fn().catch(alert);  // без catch будет Uncaught promise error
```
___

Пример **await с Promise.all:**

```
const result = await Promise.all([
  fetch(url1),
  fetch(url2)
]);  // можно добавить catch для отлова ошибок
```
___
___

## Generator

**Генератор** - функция которая возвращает множество значений по очереди; вызов функции возвращает объект-генератор  
с методом `next()`.

```
function* generator() {  // либо function *generator() {}
  yield 1;
  yield 2;

  return 3;  // если нет return, то next() будет работать циклически
}

const newGenerator = generator();

newGenerator.next();  // {value: 1, done: false}  
newGenerator.next();  // {value: 2, done: false}
newGenerator.next();  // {value: 3, done: true}
```

`yield` - выполняет код до ближайшей инструкции yield, где выполнение приостанавливается и возвращается значение;  
возвращает объект вида `{value: 123, done: false}`; `done` указывает есть ли ещё yield, если это последний, то `done: true`.

Генератор - итерируемый объект (`for of`); для перебора в цикле, последняя инструкция должна быть `yield`.  
Так же можно `[...generator()]`.
___

Генератор добавлен в JS для итерируемых объектов.

Пример использования генератора для итерируемого объекта:

```
const range = {
  from: 1,
  to: 5,
  *[Symbol.iterator]() {
    for (let v = this.from; v <= this.to; v++) {
      yield v;
    }
  }
};

console.log([...range]);  // 1,2,3,4,5
```
___

**Композиция генераторов** - возможность встраивать генераторы друг в друга с помощью `yield*`; по сути вывод одного  
генератора передаётся на вход следующего.

```
function* genSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* genPassword() {
  yield* genSequence(47, 76);
  yield* genSequence(78, 96);
  yield* genSequence(99, 142);
}
```
___

`yield(arg)` - передаёт в генератор `arg`, который становится результатом текущего yield.

`generator.throw(new Error)` - выбросит исключение в первом yield.
___

**Асинхронные генераторы** - позволяют перебирать данные, поступающие асинхронно.

**Асинхронный объект-итератор** создаётся почти как обычный объект-итератор, но:  
1. вместо `Symbol.iterator` - `Symbol.asyncIterator`
2. `next()` должен возвращать промис

Для перебора используется `for await of`:

```
const range = {
  from: 1,
  to: 5,
  [Symbol.asyncIterator]() {  // вернёт объект-итератор
    return {
      current: this.from,
      last: this.to,
      async next() {  // автоматически оборачивается в промис, благодаря async
        await this.current <= this.last ?
          {
            value: this.current++,
            done: false
          }
          :
          {done: true}
      }
    };
  }
};

(async () => {
  for await (let v of range) alert(v);
})();
```

```
// то же, но через async generator
...
async *[Symbol.asyncIterator]() {
  for (let v = this.from; v <= this.to; v++) {
    await new Promise((res) => setTimeout(res, 100));
    yield v;
  }
}
...
```
___
___

## Modules

- использует `use strict` внутри
- отдельная область видимости (всё что нужно отдать наружу - через `export`)
- код модуля выполняется **1 раз** при первом импорте
- по сути module = file
- `this` в модуле на верхнем уровне - undefined
___

`<script type="module">` - создаёт независимую область видимости для script.
___

`import.meta` - содержит инфо о модуле (например url скрипта).
___

`import/export` - нее работает при локальном запуске скрипта, нужно запускать через live server VSC.
___

Модуль по дефолту выполняется отложенно (**defer**), как `<script defer>`.  
Т.е. загрузка модуля не блочит парсинг html, но выполняется после загрузки html.  
По этому код модуля видит весь DOM.

```
<body>
  <script type="module">alert(2)</script>
  <script>alert(1)</script>  // выполнится раньше
</body>
```
___

**Минус defer загрузки** - браузер покажет html-страницу до того как выполнится скрипт (лучше предусмотреть loader/skeleton).
___

`<script async type="module">` - загрузит и выполнит скрипт по готовности; полезно для независимых от основного кода  
скриптов (реклама, счётчики, обработка событий).
___

`<script nomodule>` - резервный скрипт для старых версий браузеров, которые не поддерживают type="module".
___

**bare module** - (голый модуль) модуль без пути; запрещён в браузере, но используется если код собирается бандлером.

```
import React from 'react';  // webpack сфм добавляет путь в голому модулю
```
___

Модули обычно **используются вместе со сборщиками** (webpack например).

Алгоритм сборки:
- анализирует зависимости (import/export)
- собирает бандл (или несколько), заменяет нативный импорт на свой, позволяющий использовать голые импорты
- дополнительная трансформация кода:
  - удаление недостижимого кода
  - tree-shaking (удаляет неиспользуемые экспорты)
  - удаление dev операторов (console.log, debugger, etc)
  - транспиляция в более старый формат (babel)
  - минимизация, аглификация
___

`import *` - импортирует всё в виде объекта.

```
import * as foo from './foo.js';

foo.some();
```
___

`import {foo as bar} from '.';` - импорт под другим именем.
___

`export default` - дефолтный экспорт может быть только 1 в модуле; импортируется без фигурных скобок.

У экспортируемой по дефолту сущности может не быть имени, т.к. такой экспорт всегда 1 на модуль (файл), и имя указывается  
при импорте (причём любое свободное).
___

```
function foo() {}

export {foo as default};  // тоже что export default foo
```
___

```
// дефолтный и именованный импорт вместе
import {default as User, foo} from './user.js';
```
___

**Reexport** - (`export from`) используется для реализации public api, т.е. 1 index файл, который сначала импортирует в себя и сразу экспортирует (единая точка входа).

```
// index.js

// для именованного экспорта
export {foo, bar} from './user.js';
export * from './user.js';

// реэкспорт дефолтного экспорта
export {default as User} from './user.js';
export {default} from './user.js';
```
___

`import './script.js';` - подключит и запустит модуль без присваивания переменной.
___

`import(module)` - динамический импорт; вернёт промис, результатом которого станет объект модуля, после того как загрузится.

Даёт возможность динамически загружать модуль в зависимости от условия, по клику и пр.

`import()` можно использовать везде в скрипте, в т.ч. в блоке {}.

```
import('./module.js')  // import() похож на синтаксис функции, но это не функция
  .then(module => {})
  .catch(err => {});
```

```
(async () => {
  let {foo, bar} = await import('./module.js');

  foo();
})();
```
___
___

## Proxy, Reflect

**Proxy** - объект-обёртка, который оборачивает целевой объект и может перехватывать управление над ним (чтение,  
запись, и пр.).

`Proxy(target, handler)` - встроенный класс JS для создания и работы с прокси.
- `target` - оборачиваемый объект (в т.ч. функция)
- `handler` - объект с ловушками (traps)
  - `traps` - методы перехватчики операций
___

Прокси-объект это особый объект не имеющий своих свойств.  
С пустым `handler` он перенаправляет все операции на target объект.
___

Для действий над нативным объектом используются внутренние методы ( типа `[[Get]]`, `[[Set]]`, etc), handler прокси  
как раз перехватывает их.
___

```
// переопределение дефолтного поведения
const nums = [1, 2];
const numsProxy = new Proxy(nums, {
  get(target, prop) {
    return prop in target ? target[prop] : 'нету';
  }
});

nums[2];  // undefined
numsProxy[2];  // 'нету'
```
___

**proxy traps:**
- `get` - чтение свойства
- `set` - запись свойства
- `has` - оператор `in`
- `deleteProperty`
- `apply` - вызов функции
- `construct` - `new`
- `getPrototypeOf` - Object.getPrototypeOf()
- `setPrototypeOf`
- `isExtensible` - метод заморозки объекта Object.isExtensible()
- `preventExtensions` - Object.preventExtensions()
- etc

Ловушки должны возвращать определённое значение, описанное в спеке.
___

Прокси обычно **перезаписывает** оригинальный объект.

```
let nums = [1, 2];

nums = new Proxy(nums, {...});
```
___

```
// пример валидации через ловушку set
let nums = [1, 2];

nums = new Proxy(nums, {
  set(target, prop, value) {
    if (typeof value !== 'number') return false;

    target[prop] = value;

    return true;  // обязательное значение, которое должна реализовать ловушка set
  }
});
```
___

```
// пример с ловушкой ownKeys
let user = {
  name: 'Anna',
  age: 44,
  _pass: '0000'
};

user = new Proxy(user, {
  ownKeys(target) {
    return Object.keys(target).filter(key => !key.startsWith('_'));
  }
});

Object.keys(user);  // ['name', 'age'] исключит свойство на '_' только из перебора, чтобы полностью защитить '_' свойства
                    // нужны также ловушки: get, set, deleteProperty, has
```
___

С помощью прокси можно сделать **observable**, т.е. наблюдаемый объект.
___

```
// пример с has (sexy)
let range = {
  from: 1,
  to: 10
};

range = new Proxy(range, {
  has(target, prop) {
    return prop >= target.from && prop <= target.to;
  }
});

5 in range;  // true
11 in range;  // false
```
___

**Прокси-декоратор** перенаправляет запросы к  свойствам `length` и `name` к оригинальной функции. Обычный декоратор  
направляет такие запросы у обёртке, у которой `length == 0`, `name == ''`.

```
// пример ловушки для функции
function delay(fn, ms) {
  return new Proxy(fn, {
    apply(target, thisArg, args) {
      setTimeout(() => target.apply(thisArg, args), ms);
    }
  });
}
```
___

Проксирование снижает производительность.
___

`Proxy.revocable` - отключаемый прокси; может быть отключен вызовом функции `revoke()`; позволяет отключить  
доступ к объекту.

```
let { proxy, revoke } = Proxy.revocable(target, handler);

revoke();  // proxy теперь недоступен
```
___

Если прокси использовать для **встроенных объектов** или приватных полей (`#`), то ловушки не сработают, нужно  
привязать контекст.
___

`Reflect` - встроенный объект, упрощает создание прокси (дополнительное api к Proxy).

**Методы Reflect** имеют те же названия что ловушки прокси.

```
let user = {};

Reflect.set(user, 'name', 'Anna');

user.name;  // 'Anna'
```

По сути методы **Reflect перенаправляют (отражают)** вызов внутри ловушки прокси обратно на объект.

```
let user = {name: 'Anna'};

user = new Proxy(user, {
  get(target, prop, receiver) {  // receiver - ссылка на this
    console.log(`Get ${prop}`);  // side effect

    return Reflect.get(target, prop, receiver);  // перенаправляет действие обратно на объект
  }
});
```
___
___


