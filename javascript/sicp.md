**SICP** - Structure and Interpretation of Computer Programs.

**Цикломатическая сложность** - структурная мера сложности ПО; зависит от количества независимых маршрутов через код.

> Пример:  
> Цикломатическая сложность = 1 если нет никаких ветвлений и циклов.  
> Функция с одним `if` - циклом. сложность = 2.

**Guard Expression** - `if (condition) return ...`.

> Функция которая возвращает функцию всегда генерирует новую; часто в имени используется `generateFoo` - такая  
> функция возвращает функцию.

**Замыкание** - функция которая запомнила окружение в котором была создана.

**Предикат** - функция возвращающая true/false.

```
// функция flip - меняет аргументы местами

const flip = (fn) => (a, b) => Fn(b, a);
```

```
// частичное применение

const partialApply = (f, arg1) => (arg2) => f(arg1, arg2);
```

___

## Compound data

**Составные данные** - внутри хранят набор значений, но оперируем ими как единым целым.

**Function as first-class object** - функции могут использоваться как данные.

**Абстракция данных** - метод отделения частей ПО которые занимаются представлением данных, от частей ПО которые  
используют данные.

**Интерфейс** - клей между абстрактными и конкретными данными;  
это набор функций, состоит из:  
- конструкторов - делают из набора данных составной объект  
- селекторов - извлекают части составного объекта

**Абстрактные данные** - не делаем никаких предположений кроме необходимых, чтобы рассуждать в терминах этих данных.

**Квадрант**
```
           ^ y        
   (2)     |    (1)
           |0
---------------------->
           |          x
   (3)     |    (4)
           |
```

`cons` - constructor; функция создания пары.

`car`, `cdr` - (тема из lisp, в JS пар нет) селекторы; car - первое значения, cdr -  (читается кудр) второе значение пары.

```
// реализация конструктора, селекторов пар

const cons = (a, b) => (msg) => {
  switch (mes) {
    case 'car': return a;
    case 'cdr': return b;
  }
};

const car = (pair) => pair('car');
const cdr = (pair) => pair('cdr');
```

**Рациональное число** - простая дробь - числитель/знаменатель (как пример абстракции).

**Барьер абстракций** - соблюдение уровней абстракции, т.е. абстракции одного уровня не лезут на другой уровень.

## Sequences

**Последовательность** - упорядоченная совокупность данных (например: натуральные числа, числа фибоначчи).

**Односвязный список** - каждый элемент хранит значение и ссылку на другой элемент списка.

**Голова** - первый элемент списка.

**Хвост** - все элементы после первого.

`iter` - внутрення функция; используется внутри функции вызываемой рекурсивно, для сохранения промежуточного  
состояния.

```
const revers = (list) => {
  const iter = (items, acc) => isEmpty(items) ? acc : iter(tail(items), consList(head(items), acc));

  return iter(list, l());
};
```

**Полнота по Тьюрингу** - формальный критерий; говорит о возможности реализовать вычислимую функцию.  
Например html - не полный по Тьюрингу язык.

**Свёртка** - то что делает reduce (fold в других яп).

## Иерархические структуры

> Пример: деревья.

Состоят из:  
- **корневой узел** - самый верхний узел  
- **узел** - любой элемент дерева (вершина, нода)  
- **лист** - узел без дочерних элементов

> Деревья определяются и обрабатываются с помощью рекурсии.

**Рекурсия бывает:**
- **линейная** - содержит один вызов  
- **древовидная** - содержит два вызова, что создаёт дерево вызовов.

**Обход в глубину** - сначала спускаемся до конца левой ветки, затем берём ветку правее и т.д.

**Агрегация** - обход дерево в глубину с аккумулятором.

## Уровневое проектирование

> Подход к проектированию, когда сложной системе придаётся структура при помощи уровней.  
> Каждый уровень строится путём комбинирования элементарных для этого уровня частей.  
> Составные элементы предыдущего уровня работают как элементарные на следующем уровне.  
>
> Пример: сетевая модель OSI.

### Модель OSI

> **OSI** - Open system interconnection; архитектурная модель сети; разбивает весь процесс взаимодействия по сети  
> на 7 уровней.

(7) **Application layer** - прикладной уровень; верхний уровень модели; отвечает за взаимодействие пользовательских  
приложений с сетью. (HTTP, FTP, POP3, SMTP, WebSocket)

(6) **Presentation layer** - уровень представления; отвечает за преобразование протоколов и кодирование/декодирование  
данных. (SSL, gzip, ASCII)

(5) **Session layer** - сеансовый уровень; обеспечивает поддержание сеанса связи, позволяя приложениям  
взаимодействовать длительное время. (gRPC, RPC, PAP, L2TP)

(4) **Transport layer** - транспортный уровень; отвечает за обеспечение надёжной передачи данных от отправителя к  
получателю. (TCP, UDP, SCTP)

(3) **Network layer** - сетевой уровень; отвечает за определение пути передачи данных. (IPv4, IPv6)

(2) **Data link layer** - канальный уровень; обеспечение взаимодействия сетей на физическом уровне, контроль  
ошибок. (Ethernet, DSL)

(1) **Physical layer** - физический уровень; нижний уровень модели; определяет физический метод передачи  
данных, представленных в двоичном коде, между устройствами. (USB, wifi radio, RJ - витая пара)

**Преимущество уровневого проектирования** - возможность изменения реализации одного уровня без изменения других.

___

**Аддитивность** - возможность расширения функционала программы без переписывания исходного кода.

**Инвертирование** - техника позволяющая тестировать не детерминированные функции (например с рандомным выбором).  
Суть: если функция использует внутри random значение, то его нужно вынести в параметры функции (можно сделать  
дефолтным), тогда при тестировании можно передать свой алгоритм.

```
// не тестируемый вариант

const randomStr = (str) => str + Math.random();

// инвертирование

const randomStr = (str, random = Math.random) => str + random();
```

**Диспетчеризация** - процесс выбора решения в зависимости от условия (reducer в Redux - пример диспетчеризации по типу).

**Динамическая диспетчеризация** - диспетчеризация с помощью таблиц соответствий;  
один из вариантов реализации полиморфизма;  
в основе ООП динамическая диспетчеризация.

**Мультиметоды** - подход из closure для создания динамической диспетчеризации.

```
// выбирает нужную функцию из таблицы соответствий по тегу и вызывает её

const getName = (self) => getMethod(self, 'getName')(contents(self));
```

**Передача сообщения** - способ работы с объектом; когда обработчик внутри объекта выбирается в зависимости  
от сообщения.

> В js не используется работа с сообщениями (как в Ruby, php), но можно реализовать подобное через Proxy ES6.

**Boxing** - подкапотный процесс оборачивания примитива в объект определённого класса, при обращении типа  
`'string'.length`.

**Class** - структура позволяющая создавать новые объекты.

> Class обычно экспортируется по дефолту, 1 модуль = 1 class.

> `this` присутствует в constructor и других функциях класса неявно нулевым аргументом.  
> В конструкторе `this == {}` - пустой создаваемый объект.

> В js class - это синтаксический сахар над системой прототипов;  
> `typeof Class == function`.

## Полиморфизм

**Полиморфизм** - способность функции обрабатывать данные разных типов.

> Полиморфизм повышает коэффициент повторного использования кода, сокращает дублирование.

**Виды полиморфизма:**
- ad-hoc (специальный)
- параметрический
- подтипов (включения)

**Параметрический полиморфизм** - вызов одного и того же кода для всех допустимых типов (полиморфных) аргументов;  

> в FP этот тип обычно называется просто полиморфизм;  
> в языках с динамической типизацией такой полиморфизма есть по дефолту (`concat()`);  
> в ООП языках (Java, C++) параметрического полиморфизма из коробки нет, используются дженерики.

**Ad-hoc полиморфизма** - (лат. как есть) в зависимости от типа аргументов, применяется разная реализация операции;

```
// оператор + по разному работает для разных типов операндов

1 + 1;  // 2
'cat' + 'dog';  // catdog
```

> В статических языках ad-hoc полиморфизм реализуется за счёт перегрузки функций (т.е. описываются разные тела функций,  
> в зависимости от типов аргументов);  
> в динамических языках через `if/switch`.

**Полиморфизм подтипов** - позволяет вызывать разный код для разных иерархий типов.

> В ООП языках этот тип называют просто полиморфизмом.

## Collections

**Массив** - структура данных, содержащая упорядоченный набор элементов, предоставляет возможность  
произвольного доступа к элементам.

`undefined` - при обращении к несуществующему индексу или пустому значению массива (`[1,, 3]`).

`[]` - синтаксический сахар над `new Array()`.

`delete` - странный оператор удаления элемента.

```
const arr = [1, 2, 3];

delete arr[1];
arr.length;    // 3
arr[1];   //  undefined
arr;   // [1,, 3]
```

`for..of` - цикл для массивов, но лучше использовать функции высшего порядка (встроенные map, filter, etc).

`Array` - подтип object со своими определёнными свойствами.

**FIFO** - first in - first out; очередь.

**LIFO** - last in - last out; стек.

### Map

**Ассоциативный массив** - абстрактный тип данных; позволяет хранить данные key-value.

> Объект часто используется как ассоциативный массив.

**Динамическое обращение к свойству** - через [].

```
const key = 'some key';

object[key];  // удобно в циклах

// также обновление свойства

obj[key] = 'some';
```

> Даже пустой объект содержит несколько наследных свойств (например `valueOf`), случайная замена которых ломает объект.

`Map` - отдельный тип.

```
const map = new Map();

// methods:

map.get(key);
map.set('key', 'value');  // возвращает новый map, позволяет создавать цепочку вызовов
map.size;
map.keys();
map.values();
map.entries();
map.forEach((value, key) => {...});  // перебор в порядке добавления значений
```

> Ключи в Map могут быть любых типов js, в том числе другой Map.

___

### Set

**Set** - коллекция уникальных значений, дубли удаляются.

```
const set = new Set([1, 2, 1, '1']);

set.size;  // 3
```

**Множество** - тип и структура данных которая является реализацией математического объекта множества.

```
const set = New Set([]);

set.add()
set.size
set.has()
set.delete()
set.keys()
set.values()
set.forEach(value => {...})
```

`Array.from(set)` - преобразование в массив.

___

## Immutable

**Императивный подход** - возвращается изменённая структура данных.

**Функциональный подход** - возвращается новая структура данных, преобразованная копия.

```
class Enumerable {
  constructor(coll) {
    this.coll = coll;
  }

  where(fn) {
    const filtered = this.coll.filter(fn);

    return new Enumerable(filtered);
  }
}
```

**in-place замена** - например `sort()`, которая меняет данные.

```
// как обойти in-place замену

const arr = [4, 3, 1];
const sorted = arr.slice().sort();  // slice() без аргументов создаёт копию массива
```

___

## Lazy Evaluation


