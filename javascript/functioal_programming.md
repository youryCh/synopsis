# Functional programming

> **JavaScript** - мультипарадигменный язык, т.е. позволяет смешивать ООП, ФП и процедурное программирование.

**Иммутабильность** - неизменяемость данных, основной принцип ФП.

> **Преимущество ФП** - чёткое разделение данных и логики (т.е. функций).  
> В ООП данные и методы смешаны в одном объекте.

> **FP-парадигма** - в программе процесс вычисления трактуется как вычисление значений функции,  
>  в математическом понимании.  
>
> ФП предполагает обходиться вычислением функций от исходных данных и результатов вычислений  
> других функций, и не предполагает явного хранения состояния программы.

> **В FP не используются:**
> - циклы (while, for, etc)
> - let объявление переменной
> - void функции
> - мутирующие методы: pop, push, reverse, shift, sort, splice, unshift
> - методы Map: clear, delete, set
> - методы Set: add, clear, delete

## Основные концепции FP

### Чистые функции

**Ссылочная прозрачность** - функция возвращает одинаковые значения для одних и тех же аргументов.

Без **побочных эффектов**, таких как: ввод/вывод (console.log, etc), мутация объектов, переназначение переменных.

```
// пример чистой функции
function mul(a, b) {
  return a * b;
}
```

> void-функции грязные по определению, т.к. содержат сайдэффекты.

> Чистая функция может использовать внешние переменные (замыкание), если они объявлены через const, т.е. неизменяемы, иначе будет грязная.

**Преимущества частых функций:**
- легко отслеживать, т.к. не зависит от изменяемого состояния
- возвращаемое значение может быть кешировано
- проще тестировать, т.к. нет зависимостей

### Иммутабильность (неизменяемость)

> Иммутабильность касается всех структур данных, таких как array, Map, Set, object.  
> Т.е. методы как push, pop, sort, split не применяются в ФП.  

> Каждый мутирующий метод должен быть заменён функцией, возвращающей новый объект + изменения.  
> Пример:  
> - `concat` вместо `push/unshift`  
> - `slice` вместо `pop/shift`  
> - `R.sort/R.reverse` - Ramda функции, работающие с копией (или тоже в lodash) вместо `sort/reverse`  
> - `new Map([...map, ['key': 'value']])` вместо `map.set('key', 'value')`  
> - `new Map()` вместо `map.clear()`  

Иммутабильность в typescript:  
- `Object.freeze()`
- `Readonly<T>`
- `ReadonlyArray<T>`
- `ReadonlyMap<k, v>`
- `ReadonlySet<T>`  
не допускают мутацию на этапе компиляции.

### Композиция функций

> Последовательность из любого количества функций; результат возвращаемый функцией,  
> используется как входные данные для следующей функции.

> Один из способов составления функций - взять выходные данные из функции и передать в следующую.

```
// функции выполняются справа налево
const y = f(g(h(1)));

const result = (str) => str.trim().split('').join('_');
```

> Программа в ФП - в идеале просто композиция функций (без циклов и пр.).

> `for, let, push, etc` - это из процедурного программирования (императивный стиль).

### Рекурсия

> **Рекурсия** - один из главных инструментов ФП; иммутабильный эквивалент цикла for.  
> Состоит из рекурсивного и базового случая. Базовый случай по сути условия выхода из рекурсии.

```
function factorial(n) {
  if (n === 0) return 1;  // базовый случай (0! = 1)

  return n * factorial(n -1);  // рекурсивный случай
}

// оптимизированный вариант
function factorial(n, result = 1) {
  if (n === 0) return result;

  return factorial(n - 1, result * n);
}
```

### Функции высшего порядка

**First-class function** - функция как объект первого класса, т.е функцию можно рассматривать как значение,  
работать с ней как с данными.  

Функцию можно:  
- передать как значение
- вернуть из функции
- использовать как callback-функцию (т.е. как аргумент для другой функции)
- хранить ссылку на функцию в переменной

`filter map reduce` - функции высшего порядка, т.к. принимаю callback.

### Каррирование

> **Каррирование** - это процесс трансформации функции с n аргументами в цепочку вложенных функций с одним аргументом;  
> позволяет использовать частичное применение функции.  
> Каррирование применимо только к функции **с фиксированным** количеством аргументов.

> **Частичное применение** - использование каррированной функции с не всеми аргументами.

```
// пример с функцией curry из Lodash
function add(a, b) {
  return a + b;
}

const curriedAdd = _.curry(add);
const add2 = curriedAdd(2);

add2(3);
```

```
// пример частичного применения без каррирования
function func1(a, b, c) {
  return a + b + c;
}

const func2 = func1.bind(null, 1);
const func3 = func2.bind(null, 2);
const resultFunc = func3(3);
```

___

## Композиция функций

> **Композиция** - способ построения больших модулей из мелких; упрощает отладку,  
> тестирование, поддержку кода.

> В композиции входные данные одной функции приходят из выходных данных предыдущей функции.

**Два вида композиции:**
- compose  
- pipe

### Compose

> Композиция функций, которая выполняется справа налево.

```
const compose = (f, g) => (x) => f(g(x));

const user = {
  name: 'John',
  age: 38
};
const getAge = (user) => user.age;
const isAgeAllowed = (age) => age >= 18;

const isAllowedUser = compose(
  isAgeAllowed,
  getAge
);

isAllowedUser(user); // true

// реальный пример
const compose = (...fns) => {
  return (x) => fns.reduceRight(
    (acc, fn) => fn(acc),
    x
  );
};
```

### Pipe

> Как и compose, объединяет функции в цепочку, но выполняется в обратном порядке - слева направо;  
> pipe визуально понятнее чем compose.

```
const reverseString = (str) => str
  .split('')
  .reverse()
  .join('');

// реальный пример
const pipe = (...fns) => {
  return (x) => fns.reduce(
    (acc, fn) => fn(acc),
    x
  );
};

pipe(
  fn1,
  fn2,
  fn3
)(arg);
```

### Async pipe

> Композиция для функций, которые возвращают Promise.

```
const asyncPipe = (...fns) => (x) => fns.reduce(
  async (acc, fn) => fn(await acc),
  x
);
```
___

## Пример функции в ФП стиле

```
// рекурсия вместо цикла
function sum(arr) {
  return arr.length && arr[0] + sum(arr.slice(1));
}
```

___

## FP vs OOP

> ФП и ООП нельзя противопоставлять, ФП противопоставляется императивному программированию, где всё на мутациях.  
>
> ООП - про диспетчеризацию (т.е. про выбор реализации), что хорошо сосуществует с ФП стилем.  

> **Основная характеристика ООП** - объект сам определяет какую операцию осуществлять, когда по отношению к нему  
> применяется операция.

___


