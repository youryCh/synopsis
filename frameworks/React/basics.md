**React** - кроссплатформенный фреймворк для создания SPA приложений (html файл получаем 1 раз с сервера, дальше  
контент генерируется динамически).

**Плюсы SPA:**
- простая реализация бизнес логики
- быстро работает
- экономит трафик
- легкие запросы на сервер, но их много
- легко реализовать кеширование приложения

**Минусы SPA:**
- большой TTI (time to interactive)
- проблемы с SEO
___
___

## Создание приложения

### create-react-app

Библиотека для быстрой первоначальной настройки react-приложения; делает дефолтные настройки  
webpack, babel, jest, eslint, etc.

`npx create-react-app proj_name` - создание react-приложения.
___

### ReactDOM

`ReactDOM.render(what, where)` - библиотека для общения react с DOM браузера; вызывается 1 раз для рендера точки  
входа приложения.

`ReactDOM.render(element, document.getElementById('root'))`

```
// создание элемента через jsx синтаксис
// className т.к. class зарезервированное слово в js
const element = <h1 className="element">Hello</h1>;

// после babel jsx код транспилируется в это:
const element = React.createElement(
  'h1',
  {className: 'element'},
  'Hello'
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

**JSX** - специальный js синтаксис; позволяет использовать элементы DOM с прокидыванием атрибутов; синтаксический  
сахар над `React.createElement()`; с помощью babel транспилируется в js код.

`React.createElement(tag, attributes, value)` - создание элемента; при использовании jsx синтаксиса, происходит  
под капотом через babel.

`{}` - для передачи значений внутри jsx (как во Vue).

```
function Example(props) {
  return <p>{props.text}</p>
}
```

Передача пропсов в компонент:

```
const name = 'Anna';

ReactDOM.render(
  <React.StrictMode>
    <App name={name} />
  </React.StrictMode>,
  document.getElementById('root')
);
```

В классовом компоненте к пропсам обращаться через `this`:

```
<p>{this.props.name}</p>
```
___

**React компонент** - функция или класс (наследующий от React.Component и реализующий метод render), возвращающая  
react-элемент или null.

**Презентационный компонент** - глупый компонент; только для отображения переданных ему данных.

**Контейнер** - компонент с бизнес-логикой (запрос, обработка данных); является обёрткой над глупыми компонентами.
___

`index.html` - точка входа spa приложения; содержит div id="root".
___

`reportWebVitals()` - для сбора статистики.

```
// выведет статистику в консоль
reportWebVitals(console.log);
```
___

`npm run eject` - разбирает cra проект, открывает доступ к скрытым по дефолту конфигам webpack, babel.
___

## Фреймворк или библиотека?

**Фреймворк** - реализация всей архитектуры приложения; все решения основываются на подходах продиктованных  
фреймворком; фреймворк диктует как писать код (например Angular).

**Библиотека** - набор инструментов для реализации частной задачи; подход распространяется на реализацию отдельного  
компонента, не всего приложения.

React сам по себе это библиотека для реактивного рендера в DOM, но обмазанный кучей доп библиотек по сути становится  
фреймворком.

**Императивный стиль** - описывает шаги КАК добиться желаемого результата.

**Декларативный стиль** - описание какой результат нужен.

React использует декларативный подход - мы указываем какое состояние должен иметь интерфейс и react сам заботится  
о достижении требуемого состояния.
___
___

## Component lifecycle

**Этапы жизненного цикла:**
1. mount - монтирование; добавление компонента на страницу в первый раз
2. update - обновление; компонент существует, но обновились данные от которых он зависит (state, props)
3. unmount - размонтирование; компонент существует и происходит его удаление из DOM

### Методы жизненного цикла

На каждом этапе жизненного цикла React сам вызывает соответствующий метод жизненного цикла (классовые компоненты)  
или callback хуков (функциональные компоненты).

`componentDidMount()` - вызывается после рендера в DOM; здесь обычно отправляются запросы на сервер, устанавливаются  
таймеры, подписка на события.

`componentDidUpdate()` - вызывается при обновлении state/props после ререндера; первые 2 аргумента state, props до  
обновления; здесь можно выполнить сравнение состояние и пропсов до и после апдейта.

`componentWillUnmount()` - вызывается перед удалением компонента из памяти; здесь можно отменить ранее отправленные  
запросы, таймеры, подписки на события (чтобы избежать утечки памяти).

```
---------------------------------------------------
MOUNT                  constructor()
                            v
                          render()
                            v
                    componentDidMount()
                            v
UPDATE   (new props | setState() | forceUpdate())
                            v
                          render()
                            v
                    componentDidUpdate()
                            v
UNMOUNT            componentWillUnmount()
---------------------------------------------------
```

```
// пример порядка выполнения
class App extends React.Component {
  constructor(props) {
    super(props);  // 1
  }

  componentDidMount() {}  // 3

  render() {}  // 2
}
```

Если есть дочерний компонент, то порядок такой:
1. constructor
2. render
3. child constructor
4. child render
5. child componentDidMount
6. componentDidMount
___
___

## Хуки

Специальные функции, позволяют работать с состоянием и жизненным циклом компонентов.  
Имена хуков, в т.ч. кастомных, начинаются с `use` - указывает реакту что эта функция - хук.  
Хуки появились в 16 версии.

**Правила хуков:**
1. Хуки вызываются на верхнем уровне компонента или из других хуков, не из вложенных функций.
2. Нельзя использовать хуки с условными операторами, в циклах и после условного return.
3. В зависимостях нужно указывать все переменные, которые используются в коллбеке (исключения: переменные вне тела  
   компонента, функция-сеттер из useState).

### useEffect

В функциональных компонентах нет методов жизненного цикла, этот функционал достигается хуком useEffect.  
Позволяет наблюдать за изменением (например переменной) и выполнять какую-то логику (эффект).

`useEffect(cb, [dependencies])` - cd будет вызван (async) при:  
1. монтировании компонента
2. изменении одной из зависимостей

`useEffect(cb, [])` - cb выполнится только раз при монтирования компонента; аналог **componentDidMount**.

`useEffect(cb)` - cb выполнится при монтировании и каждом рендере; аналог **componentDidUpdate** (но он  
не сработает при первом рендере); чтобы получить полный аналог componentDidUpdate, надо использовать useEffect  
вместе с useRef (см 320) или useLayoutEffect.

`useEffect(() => cb)` - возвращаемый cb будет выполнен при размонтировании; аналог **componentWillUnmount**.

```
useEffect(() => {
  const handleResize = () => setWidth(window.innerWidth);

  window.addEventListener('resize', handleResize);

  return () => {
    window.removeEventListener('resize', handleResize);
  };
});
```

useEffect может вернуть только функцию, поэтому нельзя объявить async useEffect (т.к. async функция вернёт промис).  
Но можно объявить отдельную async функцию и вызвать её внутри useEffect.

**Разница между useEffect(cb, []) и componentDidMount():**

(1) ComponentDidMount:

```
                            render()
                               v
                 componentDidMount(newState)
                               v
  (код метода выполняется синхронно, задерживая следующий рендер)
                               v
                            render()
```

(2) useEffect(cb, []):

Сам cb выполняется асинхронно и не блокирует рендер. Т.е. ui отрисуется (с initial values) до того как сработает  
callback useEffect.  
В классовом компоненте такое поведение можно сымитировать так:

```
componentDidMount() {
  setTimeout(() => {});  // 0 - default delay
}
```
___

### useLayoutEffect

`useLayoutEffect(cb, [deps])` - всё так же как у useEffect, разница только в том что callback выполнится синхронно,  
т.е. задержит рендер браузера (также как componentDidMount).
___

### useCallback

`useCallback(cb, [deps])` - Используется для мемоизации коллбеков, передаваемых в дочерние компоненты; callback  
запоминается и пересоздаётся только при изменении зависимостей; возвращает переданный callback.

Зачем оно надо:

```
const Cars = () => {
  const handler = useCallback(() => {
    console.log('click');
  }, []);

  return [1, 2, 3].map(
    (car, idx) => <Car key={idx} car={car} onClick={handler}>
  );
};
```

При ререндере Cars, ссылка на handler не меняется (т.к. запоминается useCallback), поэтому не произойдёт ререндер  
дочерних компонентов Car.  
Если не оборачивать handler, то при ререндере Cars, handler создастся каждый раз заново, и Car, видя новую ссылку  
на handler, перерендерится.
___

### useMemo

`useMemo(cb, [deps])` - выполняет cb и мемоизирует результат; возвращает результат выполнения cb;  

Коллбек, переданный в useMemo будет выполнен при первом рендере и изменении зависимостей. Используется для  
тяжёлых функций, чтобы не вычислять при каждом рендере.

### useRef

`useRef(currentInitial)` - возвращает ref, который сохраняется в течении всего жизненного цикла компонента.

`ref` - специальный объект с мутируемым свойством `current`; объект ref не изменяется, current можно изменять  
не вызывая обновление компонента

Использование:
- получение ссылки на DOM элемент (например навесить focus на input) или на другой компонент
- получение состояния предыдущего рендера
- для взаимодействия с DOM элементом напрямую
- сохранение переменных, не влияющих на отображение компоненты

```
// пример кастомного хука
const usePrevious(value) => {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
};

// в классовых компонентах доступно через componentDidUpdate(prevProps, prevState)
```
Каждый DOM элемент в React имеет атрибут `ref`, в который можно передать ref-объект. Обычно такое прямое 
взаимодействие с DOM используется для focus, scroll.

```
// пример прямого взаимодействия с DOM
const Input = (props) => {
  const inputRef = useRef(null);

  const handleClick = () => {
    inputRef.current.focus();
    inputRef.current.style.backgroundColor = 'red';  // можно работать как обычным DOM элементом

    console.log(inputRef.current);  // <input>
  };

  useEffect(() => {
    inputRef.current?.focus();  // взаимодействие с элементом через ref
  }, []);                       // focus() - стандартная функция webAPI

  return (
    <input ref={inputRef}>
    <button onClick={handleClick}>Click me</button>
  );
};
```

Если нужно выполнить callback при обновлении компонента, но не при первом рендере, можно использовать ref.

```
const isFirstRender = useRef(true);

useEffect(() => {
  if (!isFirstRender.current) {
    console.log('Этот текст виден каждый рендер, кроме первого');
  }
});

useEffect(() => {
  isFirstRender.current = false;
}, []);
```
___

### useState


